<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><!-- No more cache -->
    <meta http-equiv="cache-control" content="no-cache, no-store, must-revalidate, post-check=0, pre-check=0">
    <meta http-equiv="cache-control" content="max-age=0">
    <meta http-equiv="expires" content="0">
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT">
    <meta http-equiv="pragma" content="no-cache"><!-- htmlmin:ignore -->
  </head><!-- htmlmin:ignore -->
  <body>
    <script>// based on https://github.com/hammerjs/touchemulator/blob/master/touch-emulator.js but with no polyfills
// and multi-touch support

( () => {
    let eventTarget;

    /**
     * create an touch point
     * @constructor
     * @param target
     * @param identifier
     * @param pos
     * @param deltaX
     * @param deltaY
     * @returns {Object} touchPoint
     */
    function Touch( target, identifier, pos, deltaX, deltaY ) {
        deltaX = deltaX || 0;
        deltaY = deltaY || 0;

        this.identifier = identifier;
        this.target = target;
        this.clientX = pos.clientX + deltaX;
        this.clientY = pos.clientY + deltaY;
        this.screenX = pos.screenX + deltaX;
        this.screenY = pos.screenY + deltaY;
        this.pageX = pos.pageX + deltaX;
        this.pageY = pos.pageY + deltaY;
    }

    /**
     * create empty touchlist with the methods
     * @constructor
     * @returns touchList
     */
    function TouchList() {
        const touchList = [];

        touchList.item = function( index ) {
            return this[ index ] || null;
        };

        return touchList;
    }

    /**
     * Simple trick to fake touch event support
     * this is enough for most libraries like Modernizr and Hammer
     */
    function fakeTouchSupport() {
        const objs = [ window, document.documentElement ];
        const props = [ 'ontouchstart', 'ontouchmove', 'ontouchcancel', 'ontouchend' ];

        for ( let o = 0; o < objs.length; o++ ) {
            for ( let p = 0; p < props.length; p++ ) {
                if ( objs[ o ] && objs[ o ][ props[ p ] ] === undefined ) {
                    objs[ o ][ props[ p ] ] = null;
                }
            }
        }
    }

    /**
     * disable mouseevents on the page
     * @param ev
     */
    function preventMouseEvents( ev ) {
        ev.preventDefault();
        ev.stopPropagation();
    }

    const ignoreTags = [ 'TEXTAREA', 'INPUT', 'SELECT' ];

    /**
     * only trigger touches when the left mousebutton has been pressed
     * @param touchType
     * @returns {Function}
     */
    function onMouse( touchType ) {
        return function( ev ) {
            if ( ignoreTags.indexOf( ev.target.tagName ) < 0 ) {
                // prevent mouse events
                preventMouseEvents( ev );
            }

            if ( ev.which !== 1 ) {
                return;
            }

            // The EventTarget on which the touch point started when it was first placed on the surface,
            // even if the touch point has since moved outside the interactive area of that element.
            // also, when the target doesnt exist anymore, we update it
            if ( ev.type === 'mousedown' || !eventTarget || ( eventTarget && !eventTarget.dispatchEvent ) ) {
                eventTarget = ev.target;
            }

            triggerTouch( touchType, ev );

            // reset
            if ( ev.type === 'mouseup' ) {
                eventTarget = null;
            }
        };
    }

    /**
     * trigger a touch event
     * @param eventName
     * @param mouseEv
     */
    function triggerTouch( eventName, mouseEv ) {
        const touchEvent = document.createEvent( 'Event' );
        touchEvent.initEvent( eventName, true, true );

        touchEvent.touches = getActiveTouches( mouseEv );
        touchEvent.targetTouches = getActiveTouches( mouseEv );
        touchEvent.changedTouches = createTouchList( mouseEv );

        eventTarget.dispatchEvent( touchEvent );
    }

    /**
     * create a touchList based on the mouse event
     * @param mouseEv
     * @returns {TouchList}
     */
    function createTouchList( mouseEv ) {
        const touchList = new TouchList();
        touchList.push( new Touch( eventTarget, 1, mouseEv, 0, 0 ) );
        return touchList;
    }

    /**
     * receive all active touches
     * @param mouseEv
     * @returns {TouchList}
     */
    function getActiveTouches( mouseEv ) {
        // empty list
        if ( mouseEv.type === 'mouseup' ) {
            return new TouchList();
        }

        return createTouchList( mouseEv );
    }

    let element = null;

    /**
     * show the touchpoints on the screen
     */
    function showTouches( ev ) {
        if ( !element ) {
            element = document.createElement( 'div' );
            const s = element.style;
            s.display = 'none';
            s.position = 'fixed';
            s.background = '#fff';
            s.border = 'solid 1px #999';
            s.opacity = 0.6;
            s.borderRadius = '100%';
            s.height = '30px';
            s.width = '30px';
            s.overflow = 'hidden';
            s.pointerEvents = 'none';
            s.userSelect = 'none';
            document.body.appendChild( element );
        }

        switch ( ev.type ) {
            case 'touchend':
                element.style.display = 'none';
                break;
            case 'touchstart':
                element.style.display = 'block';
                // fallthrough
            case 'touchmove':
                element.style.transform = 'translate(' + ( ev.touches[ 0 ].clientX - 15 ) + 'px, ' + ( ev.touches[ 0 ].clientY - 15 ) + 'px)';
        }
    }

    if ( 'ontouchstart' in window || navigator.maxTouchPoints > 2 ) {
        return;
    }

    Object.defineProperty( window.navigator, 'maxTouchPoints', {
        get: function() {
            return 2;
        },
    } );

    fakeTouchSupport();

    addEventListener( 'mousedown', onMouse( 'touchstart' ), true );
    addEventListener( 'mousemove', onMouse( 'touchmove' ), true );
    addEventListener( 'mouseup', onMouse( 'touchend' ), true );

    addEventListener( 'mouseenter', preventMouseEvents, true );
    addEventListener( 'mouseleave', preventMouseEvents, true );
    addEventListener( 'mouseout', preventMouseEvents, true );
    addEventListener( 'mouseover', preventMouseEvents, true );

    addEventListener( 'touchstart', showTouches, false );
    addEventListener( 'touchmove', showTouches, false );
    addEventListener( 'touchend', showTouches, false );
} )();

    </script>
    <style>.preloader {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 19999;
    overflow: hidden;
    user-select: none;
}

.preloader__luna__logo {
    position: absolute;
    top: 82.6%;
    transform: translate(-50%, -50%);
    left: 50%;
    width: 20vmax;
    max-width: 220px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.preloader__luna__logo * {
    width: 100%;
    height: 100%;
}

.preloader__background__color__overlay{
    position: absolute;
    background-color: #000000;
    width: 100%;
    height: 100%;
    z-index: -1;
}

@media (orientation: portrait) {
    .preloader__wrapper {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        opacity: 1;
        z-index: 1;
    }

    .wrapper{
        margin-bottom: 3.5vmax;
        text-align: center;
    }
}

@media (orientation: landscape) {
    .preloader__wrapper {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        opacity: 1;
        z-index: 1;
        margin-top: -2vmax;
    }

    .wrapper{
        margin-bottom: 3.5vmin;
        text-align: center;
    }
}

.preloader__container {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 13vmax;
    height: 1.8vmax;
}

.preloader__outer__bar {
    display: flex;
    justify-content: left;
    align-items: center;
    width: 100%;
    height: 1.2vmax;
    margin: 0.4vmax;
    border-radius: 1000px;
}

.preloader__outer__bar:before {
    content: '';
    position: absolute;
    border: 0.3vmax solid #fff;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: 100vh;
}

.preloader__bar {
    width: 0;
    height: calc(100% - 0.4vmax);
    margin: 0.2vmax;
    border-radius: 10000px;
    box-sizing: border-box;
    background: white;
    animation: loading 8s forwards;
}

.preloader__icon {
    width: 15vmax;
    height: 15vmax;
    border-radius: 25%;
    z-index: 3;
}

.preloader__name{
    font-size: 2vmax;
    font-weight: bold;
    font-family: Helvetica, sans-serif;
    color: white;
    text-align: center;
    margin-left: 20px;
    margin-right: 20px;
}

@keyframes loading {
    0%{
        width: 0;
    }
    100%{
        width: calc(100% - 0.4vmax);
    }
}

    </style>
    <div class="preloader" id="application-preloader">
      <div class="preloader__background__color__overlay" id="parameter/preloader/color" style="background:#000000;"><span class="preloader__luna__logo"><svg width="222" height="39" viewBox="0 0 222 39" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M54.7893 21.3079C54.7893 23.1441 53.7655 24.4517 51.6085 24.4517C49.3221 24.4517 48.3752 23.2208 48.3752 21.3846V10.1657H43.7214V21.2272C43.7214 25.6059 46.3477 28.1725 51.6045 28.1725C56.8329 28.1725 59.435 25.5534 59.435 21.2272V10.1697H54.7812V21.3079H54.7893Z" fill="white"/>
<path d="M69.9849 14.0237C68.1194 14.0237 66.8325 14.8106 65.833 16.2513H65.752V14.4151H61.6243V27.8335H65.9098V20.4201C65.9098 18.7696 66.8568 17.5912 68.2732 17.5912C69.6653 17.5912 70.3775 18.5597 70.3775 19.9762V27.8375H74.663V19.1085C74.663 16.1222 72.927 14.0237 69.9849 14.0237Z" fill="white"/>
<path d="M81.15 9.09624H76.8645V12.5588H81.15V9.09624Z" fill="white"/>
<path d="M81.15 14.4151H76.8645V27.8335H81.15V14.4151Z" fill="white"/>
<path d="M88.6972 10.1697H84.5169V14.4151H82.7282V17.8777H84.5169V24.2983C84.5169 27.1797 86.3056 27.9949 88.8025 27.9949C89.9598 27.9949 90.7732 27.89 91.1415 27.7851V24.6656C90.9837 24.6656 90.5628 24.6938 90.1945 24.6938C89.2759 24.6938 88.6972 24.4315 88.6972 23.3822V17.8777H91.1415V14.4151H88.6972V10.1697Z" fill="white"/>
<path d="M100.263 20.1296C99.8421 21.4411 99.4738 23.2208 99.4738 23.2208H99.4212C99.4212 23.2208 99.0003 21.4371 98.5795 20.1296L96.7665 14.4151H92.2463L96.2161 24.7422C96.7665 26.1587 97.0296 26.9457 97.0296 27.5187C97.0296 28.4348 96.5318 28.9352 95.2692 28.9352H93.7962V32.2646H96.5804C99.2877 32.2646 100.575 31.1629 101.651 28.0191L106.305 14.4151H102.019L100.263 20.1296Z" fill="white"/>
<path d="M18.8256 6.97755L25.0172 10.541C25.2397 10.6661 25.2478 11.0131 25.0172 11.1382L17.6601 15.3756C17.4376 15.5048 17.1745 15.4967 16.9681 15.3756L9.61109 11.1382C9.38447 11.0172 9.38043 10.662 9.61109 10.541L15.7986 6.97755V0L0 9.09624V27.2887L6.05802 23.8019V16.6751C6.05398 16.4208 6.35344 16.2392 6.57601 16.3764L13.9331 20.6138C14.1556 20.743 14.2811 20.973 14.2811 21.2111V29.6818C14.2851 29.9361 13.9857 30.1177 13.7631 29.9804L7.57152 26.417L1.51349 29.9038L17.3121 39L33.1107 29.9038L27.0527 26.417L20.8611 29.9804C20.6426 30.1136 20.3351 29.9401 20.3431 29.6818V21.2111C20.3431 20.9569 20.4848 20.7309 20.6912 20.6138L28.0482 16.3764C28.2667 16.2433 28.5743 16.4128 28.5662 16.6751V23.8019L34.6242 27.2887V9.09624L18.8256 0V6.97755Z" fill="white"/>
<path d="M221.476 17.8568L219.151 18.2712C219.054 17.9719 218.899 17.687 218.687 17.4165C218.482 17.146 218.201 16.9244 217.847 16.7517C217.492 16.579 217.049 16.4927 216.517 16.4927C215.79 16.4927 215.184 16.6567 214.697 16.9848C214.211 17.3071 213.968 17.7244 213.968 18.2366C213.968 18.6798 214.131 19.0367 214.457 19.3072C214.783 19.5777 215.31 19.7993 216.036 19.972L218.13 20.4554C219.343 20.7375 220.246 21.172 220.841 21.7591C221.436 22.3461 221.734 23.1088 221.734 24.0469C221.734 24.8412 221.505 25.5491 221.047 26.1707C220.595 26.7866 219.963 27.2701 219.151 27.6212C218.344 27.9722 217.409 28.1478 216.345 28.1478C214.869 28.1478 213.665 27.8312 212.732 27.1981C211.8 26.5592 211.228 25.6527 211.016 24.4786L213.496 24.0987C213.651 24.7491 213.968 25.2412 214.449 25.575C214.929 25.9031 215.556 26.0671 216.328 26.0671C217.169 26.0671 217.841 25.8916 218.344 25.5405C218.848 25.1837 219.099 24.7491 219.099 24.2369C219.099 23.8225 218.945 23.4742 218.636 23.1922C218.333 22.9102 217.867 22.6972 217.237 22.5533L215.006 22.0612C213.776 21.7792 212.867 21.3303 212.278 20.7144C211.694 20.0986 211.402 19.3187 211.402 18.3748C211.402 17.592 211.62 16.9071 212.055 16.32C212.489 15.733 213.09 15.2754 213.857 14.9473C214.623 14.6135 215.501 14.4466 216.491 14.4466C217.915 14.4466 219.036 14.7574 219.854 15.379C220.672 15.9948 221.213 16.8208 221.476 17.8568Z" fill="white"/>
<path d="M201.476 23.3822L201.459 20.231H201.905L207.156 14.6193H210.228L204.239 21.008H203.836L201.476 23.3822ZM199.116 27.8802V10.1989H201.682V27.8802H199.116ZM207.439 27.8802L202.72 21.5778L204.488 19.7734L210.589 27.8802H207.439Z" fill="white"/>
<path d="M190.809 27.8802V14.6192H193.289V16.7258H193.426C193.666 16.0121 194.09 15.4509 194.696 15.0423C195.308 14.6279 196 14.4207 196.773 14.4207C196.933 14.4207 197.122 14.4264 197.339 14.4379C197.562 14.4494 197.737 14.4638 197.862 14.4811V16.9503C197.759 16.9215 197.576 16.8898 197.313 16.8553C197.05 16.815 196.787 16.7949 196.524 16.7949C195.917 16.7949 195.377 16.9244 194.902 17.1834C194.433 17.4366 194.061 17.7906 193.787 18.2453C193.512 18.6942 193.375 19.2065 193.375 19.782V27.8802H190.809Z" fill="white"/>
<path d="M182.768 28.1478C181.532 28.1478 180.454 27.8629 179.533 27.2931C178.612 26.7233 177.897 25.9261 177.388 24.9016C176.879 23.8771 176.624 22.68 176.624 21.3101C176.624 19.9345 176.879 18.7316 177.388 17.7014C177.897 16.6711 178.612 15.8711 179.533 15.3013C180.454 14.7315 181.532 14.4466 182.768 14.4466C184.004 14.4466 185.082 14.7315 186.003 15.3013C186.924 15.8711 187.639 16.6711 188.148 17.7014C188.657 18.7316 188.912 19.9345 188.912 21.3101C188.912 22.68 188.657 23.8771 188.148 24.9016C187.639 25.9261 186.924 26.7233 186.003 27.2931C185.082 27.8629 184.004 28.1478 182.768 28.1478ZM182.777 25.9808C183.577 25.9808 184.241 25.7679 184.767 25.3419C185.294 24.916 185.683 24.3491 185.934 23.6412C186.192 22.9332 186.32 22.1533 186.32 21.3015C186.32 20.4554 186.192 19.6784 185.934 18.9705C185.683 18.2568 185.294 17.6841 184.767 17.2524C184.241 16.8208 183.577 16.6049 182.777 16.6049C181.97 16.6049 181.301 16.8208 180.769 17.2524C180.242 17.6841 179.851 18.2568 179.593 18.9705C179.341 19.6784 179.216 20.4554 179.216 21.3015C179.216 22.1533 179.341 22.9332 179.593 23.6412C179.851 24.3491 180.242 24.916 180.769 25.3419C181.301 25.7679 181.97 25.9808 182.777 25.9808Z" fill="white"/>
<path d="M161.502 27.8802L157.623 14.6192H160.275L162.858 24.3577H162.986L165.578 14.6192H168.229L170.803 24.3146H170.932L173.498 14.6192H176.149L172.279 27.8802H169.662L166.985 18.3057H166.788L164.11 27.8802H161.502Z" fill="white"/>
<path d="M147.547 32.853C147.163 32.853 146.814 32.8214 146.5 32.758C146.185 32.7005 145.951 32.6372 145.796 32.5681L146.414 30.4529C146.883 30.5795 147.301 30.6342 147.667 30.617C148.033 30.5997 148.356 30.4616 148.636 30.2026C148.922 29.9436 149.174 29.5205 149.391 28.9334L149.709 28.0528L144.887 14.6192H147.632L150.97 24.9103H151.108L154.445 14.6192H157.2L151.768 29.65C151.517 30.3407 151.196 30.9249 150.807 31.4026C150.418 31.8861 149.955 32.2487 149.417 32.4904C148.879 32.7321 148.256 32.853 147.547 32.853Z" fill="white"/>
<path d="M137.442 28.1737C136.607 28.1737 135.852 28.0183 135.177 27.7075C134.502 27.3909 133.967 26.9334 133.572 26.3348C133.183 25.7362 132.989 25.0024 132.989 24.1333C132.989 23.385 133.132 22.7692 133.418 22.2857C133.704 21.8022 134.09 21.4195 134.576 21.1375C135.062 20.8554 135.606 20.6425 136.206 20.4986C136.807 20.3547 137.419 20.2453 138.043 20.1705C138.832 20.0784 139.473 20.0036 139.965 19.9461C140.457 19.8827 140.814 19.782 141.037 19.6439C141.26 19.5058 141.372 19.2813 141.372 18.9705V18.91C141.372 18.1561 141.16 17.5719 140.737 17.1575C140.319 16.7431 139.696 16.5359 138.866 16.5359C138.003 16.5359 137.322 16.7287 136.824 17.1143C136.332 17.4942 135.992 17.9172 135.803 18.3834L133.392 17.8309C133.678 17.0251 134.095 16.3747 134.645 15.8797C135.199 15.379 135.837 15.0164 136.558 14.7919C137.279 14.5617 138.037 14.4466 138.832 14.4466C139.358 14.4466 139.916 14.5099 140.505 14.6365C141.1 14.7574 141.655 14.9818 142.17 15.3099C142.69 15.638 143.117 16.1071 143.448 16.7172C143.78 17.3215 143.946 18.1071 143.946 19.0741V27.8802H141.441V26.0671H141.338C141.172 26.401 140.923 26.729 140.591 27.0514C140.259 27.3737 139.833 27.6413 139.312 27.8543C138.792 28.0672 138.168 28.1737 137.442 28.1737ZM138 26.1017C138.709 26.1017 139.315 25.9607 139.819 25.6786C140.328 25.3966 140.714 25.0283 140.977 24.5736C141.246 24.1131 141.38 23.621 141.38 23.0972V21.3878C141.289 21.4799 141.112 21.5663 140.848 21.6468C140.591 21.7217 140.296 21.7879 139.965 21.8454C139.633 21.8972 139.31 21.9461 138.995 21.9922C138.68 22.0325 138.417 22.067 138.206 22.0958C137.708 22.1591 137.253 22.2656 136.841 22.4152C136.435 22.5649 136.109 22.7807 135.863 23.0627C135.623 23.339 135.503 23.7073 135.503 24.1678C135.503 24.8067 135.737 25.2901 136.206 25.6182C136.675 25.9405 137.273 26.1017 138 26.1017Z" fill="white"/>
<path d="M131.121 10.1989V27.8802H128.556V10.1989H131.121Z" fill="white"/>
<path d="M114.272 27.8802V10.1989H120.536C121.903 10.1989 123.036 10.4493 123.934 10.9501C124.832 11.4508 125.504 12.1357 125.95 13.0048C126.397 13.8681 126.62 14.8408 126.62 15.9229C126.62 17.0107 126.394 17.9892 125.942 18.8583C125.496 19.7216 124.821 20.4065 123.917 20.913C123.019 21.4138 121.889 21.6641 120.527 21.6641H116.22V19.4022H120.287C121.151 19.4022 121.852 19.2525 122.389 18.9532C122.927 18.6482 123.322 18.2338 123.574 17.71C123.825 17.1863 123.951 16.5906 123.951 15.9229C123.951 15.2553 123.825 14.6624 123.574 14.1444C123.322 13.6264 122.924 13.2206 122.381 12.9271C121.843 12.6336 121.134 12.4868 120.253 12.4868H116.924V27.8802H114.272Z" fill="white"/>
</svg>
</span>
        <div class="preloader__wrapper wrapper"><img class="preloader__icon wrapper" id="asset/preloader/icon" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="><span class="preloader__name wrapper" id="parameter/preloader/name"></span>
          <div class="preloader__container wrapper">
            <div class="preloader__outer__bar">
              <div class="preloader__bar"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <style>* {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
}

#application-canvas {
    margin: 0 auto;
    display: block;
    background: black;
    position: absolute;
    width: 100% !important;
    height: 100% !important;
    top: 0;
    left: 0;
}

body {
    margin: 0;
    padding: 0;
    background: #000;
    overflow: hidden;
}

    </style>
    <script>
      var $environment = {
          baseUrl: "./",
          resourceConfig: {
              json: "external",
              image: "external",
              video: "external",
              blob: "external",
              sound: "external"
          },
          packageConfig: {
              userId: -1,
              version: "6.3.0"
          },
          playerPrefs: true,
          forceIncludedClasses: ["LunaUnity.Utils.CompressedResources","LunaUnity.Utils.ExternalResources","LunaUnity.Utils.InlineResources","LunaUnity.Utils.Network","LunaUnity.Audio.Manager","Luna.Unity.Analytics","Luna.Unity.Analytics.EventType","Luna.Unity.Playable","Luna.Unity.LifeCycle","Luna.Unity.HapticFeedbackType","Luna.Unity.CallbackTypes","Luna.Unity.Nucleo","Luna.Unity.Nucleo.EventTypes","Luna.Unity.TriggerTypes","Luna.Unity.BuildPlatforms","Luna.Unity.NativeShare","Luna.Unity.FacebookInstantGames.ContextFilter","Luna.Unity.FacebookInstantGames.UpdateAction","Luna.Unity.FacebookInstantGames.Platform","Luna.Unity.FacebookInstantGames.ContextType","Luna.Unity.FacebookInstantGames.Intent","Luna.Unity.FacebookInstantGames.ErrorCodeType","Luna.Unity.FacebookInstantGames.UpdateStrategy","Luna.Unity.FacebookInstantGames.Leaderboard","Luna.Unity.FacebookInstantGames.LeaderboardEntry","Luna.Unity.FacebookInstantGames.LeaderboardPlayer","Luna.Unity.FacebookInstantGames.ConnectedPlayer","Luna.Unity.FacebookInstantGames.SignedPlayerInfo","Luna.Unity.FacebookInstantGames.ContextPlayer","Luna.Unity.FacebookInstantGames.AdInstance","Luna.Unity.FacebookInstantGames.Product","Luna.Unity.FacebookInstantGames.ContextSizeResponse","Luna.Unity.FacebookInstantGames.Purchase","Luna.Unity.FacebookInstantGames.ContextOptions","Luna.Unity.FacebookInstantGames.InvitePayload","Luna.Unity.FacebookInstantGames.SharePayload","Luna.Unity.FacebookInstantGames.APIError","Luna.Unity.FacebookInstantGames.PurchaseConfig","Luna.Unity.FacebookInstantGames.CustomUpdatePayload","Luna.Unity.FacebookInstantGames.LeaderboardUpdatePayload","Luna.Unity.FacebookInstantGames.LocalizableContent","Luna.Unity.FacebookInstantGames.DataObject","Luna.Unity.FacebookInstantGames.StatsObject","Luna.Unity.FacebookInstantGames.IncrementObject","Luna.Unity.FacebookInstantGames.LocalizationsDict","Luna.Unity.FacebookInstantGames.Player","Luna.Unity.FacebookInstantGames.Context","Luna.Unity.FacebookInstantGames.Payments","Luna.Unity.FacebookInstantGames.Tournament","Luna.Unity.FacebookInstantGames.Tournaments","Luna.Unity.FacebookInstantGames.CreateTournamentConfig","Luna.Unity.FacebookInstantGames.CreateTournamentPayload","Luna.Unity.FacebookInstantGames.ShareTournamentPayload","Luna.Unity.FacebookInstantGames.GraphApi","Luna.Unity.FacebookInstantGames.Arena","Luna.Unity.FacebookInstantGames.Arenas","Luna.Unity.FacebookInstantGames.JoinGamingSquadPayload","Luna.Unity.FacebookInstantGames.LeaveGamingSquadPayload","Luna.Unity.FacebookInstantGames.AddToGamingSquadPayload","Luna.Unity.FacebookInstantGames.CreateGamingSquadPayload","Luna.Unity.FacebookInstantGames.GamingSquad","Luna.Unity.FacebookInstantGames.Squads","Luna.Unity.FacebookInstantGames.Community","Luna.Unity.FacebookInstantGames.LiveStream","Luna.Unity.FacebookInstantGames.VideoPlayer","Luna.Unity.FacebookInstantGames.VideoPlayerInstance","Luna.Unity.FacebookInstantGames.VideoPlayerInstanceState","Luna.Unity.FacebookInstantGames.VideoPlayerPlacement","Luna.Unity.FacebookInstantGames.Room","Luna.Unity.FacebookInstantGames.LiveMatch","Luna.Unity.FacebookInstantGames.LiveMatchStatusType","Luna.Unity.FacebookInstantGames.LiveMatchPlayer","Luna.Unity.FacebookInstantGames.CameraEffectArgs","Luna.Unity.FacebookInstantGames.CameraEffects","Luna.Unity.FacebookInstantGames.FBInstant","UnityEngine.AudioSource","UnityEngine.Debug","UnityEngine.GameObject","UnityEngine.ILogger","UnityEngine.Logger","UnityEngine.ILogHandler","UnityEngine.DebugLogHandler","UnityEngine.LogType","UnityEngine.Input","UnityEngine.Touch","UnityEngine.Cursor","UnityEngine.CursorLockMode","UnityEngine.CursorMode","UnityEngine.EventSystems.EventSystem","UnityEngine.EventSystems.ExecuteEvents","UnityEngine.EventSystems.BaseInput","UnityEngine.Object","UnityEngine.Object$1","UnityEngine.Component","UnityEngine.Component$1","UnityEngine.Behaviour$1","UnityEngine.Behaviour","UnityEngine.ColorSpace","UnityEngine.MonoBehaviour","UnityEngine.EventSystems.UIBehaviour","UnityEngine.EventSystems.BaseInputModule","UnityEngine.EventSystems.PointerInputModule","UnityEngine.EventSystems.PointerInputModule.MouseState","UnityEngine.EventSystems.PointerInputModule.ButtonState","UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData","UnityEngine.EventSystems.PointerEventData","UnityEngine.EventSystems.PointerEventData.FramePressState","UnityEngine.EventSystems.StandaloneInputModule","UnityEngine.EventSystems.AbstractEventData","UnityEngine.EventSystems.BaseEventData","UnityEngine.EventSystems.AxisEventData","UnityEngine.PlayerPrefs","UnityEngine.PlayerPrefs.LocalStorageProvider","UnityEngine.PlayerPrefs.FacebookStorageProvider","UnityEngine.PlayerPrefs.IProvider","UnityEngine.LunaPlaygroundAssetAttribute","UnityEngine.LunaPlaygroundFieldArrayLengthAttribute","UnityEngine.LunaPlaygroundFieldAttribute","UnityEngine.LunaPlaygroundFieldStepAttribute","UnityEngine.LunaPlaygroundSectionAttribute","UnityEngine.EventSystems.IEventSystemHandler","UnityEngine.EventSystems.IDeselectHandler","UnityEngine.EventSystems.ISelectHandler","UnityEngine.EventSystems.IPointerExitHandler","UnityEngine.EventSystems.IPointerEnterHandler","UnityEngine.EventSystems.IPointerUpHandler","UnityEngine.EventSystems.IPointerDownHandler","UnityEngine.EventSystems.IMoveHandler","UnityEngine.UI.Selectable","UnityEngine.UI.ScrollRect","UnityEngine.UI.InputField","System.Attribute","System.Exception","System.SystemException","System.NullReferenceException","System.ArgumentException","System.ArgumentOutOfRangeException","System.AggregateException","System.Enum","System.Int32","System.IComparable","System.ICloneable","System.String","System.IAsyncResult","System.IDisposable","System.Threading.Tasks.Task","System.Threading.Tasks.TaskCompletionSource","System.Collections.ICollection","System.Collections.IDictionary","System.Collections.IEnumerable","System.Collections.IEnumerator","System.Collections.Generic.IReadOnlyCollection$1","System.Collections.Generic.IReadOnlyDictionary$2","System.Collections.Generic.IEnumerable$1","System.Collections.Generic.ICollection$1","System.Collections.Generic.KeyValuePair$2","System.Collections.Generic.IDictionary$2","System.Collections.Generic.Dictionary$2","System.Collections.Generic.IEnumerator$1","System.Collections.Generic.Dictionary$2.ValueCollection.Enumerator","System.Collections.HashHelpers","System.Collections.Generic.List$1","System.Text.RegularExpressions.Regex","System.Text.RegularExpressions.RegexEngine","System.Text.RegularExpressions.Match","System.Text.RegularExpressions.Capture","System.Text.RegularExpressions.RegexOptions","System.Text.RegularExpressions.RegexRunner","System.Text.RegularExpressions.RegexEngineParser","System.Text.RegularExpressions.RegexParser","System.Text.RegularExpressions.RegexNode","System.Text.RegularExpressions.RegexReplacement","System.Text.RegularExpressions.RegexEngineBranch","System.Text.RegularExpressions.RegexEngineState","System.Text.RegularExpressions.RegexEngineBranch","System.Text.RegularExpressions.RegexEnginePass","System.Text.RegularExpressions.RegexEngineProbe","LunaUnity.Objects.Registry","UnityEngine.Application","TMPro.TextMeshProUGUI"],
          targetPlatform: "develop",
          runtimeAnalysisModules: ["physics3d","physics2d","particle_system","reflection","prefabs","mecanim-wasm"],
      };
      
    </script>
    <script>
      window.addEventListener( 'luna:started', () => {
          Luna.LogDebugInfo = () => {
              const lablColor = 'color: #bada55';
              const descColor = 'color: #ffaa80';
              const app = pc.Application.getApplication();
      
              console.log( `%c CompanyName: %c${ UnityEngine.Application.companyName }`, lablColor, descColor );
              console.log( `%c ProductName: %c${ UnityEngine.Application.productName }`, lablColor, descColor );
              if ( window.$environment.buildId ) {
                  console.log( `%c Playground BuildID: %c${ window.$environment.buildId }`, lablColor, descColor );
              }
              console.log( `%c CreativeName: %c${ UnityEngine.Application.creativeName }`, lablColor, descColor );
              console.log( `%c UnityVersion: %c${ UnityEngine.Application.unityVersion }`, lablColor, descColor );
              console.log( `%c BuildPlatform: %c${ UnityEngine.Application.buildPlatform }`, lablColor, descColor );
              console.log( `%c Unity ProjectID: %c${ UnityEngine.Application.projectId }`, lablColor, descColor );
              console.log( `%c Unity BuildID: %c${ UnityEngine.Application.buildID }`, lablColor, descColor );
              console.log( `%c LunaPackage: %c${ UnityEngine.Application.lunaVersion } (${ UnityEngine.Application.lunaSHA })`, lablColor, descColor );
      
              console.log( `%c LunaInitializationTime: %c${ UnityEngine.Application.lunaInitializationTime } ${ UnityEngine.Application.lunaDaysSinceInstall } day(s) running`, lablColor, descColor );
              const isIronSource = window.$environment.targetPlatform === 'ironsource';
              console.log( `%c AdNetworkPlatform: %c${ window.$environment.targetPlatform } API: ${ isIronSource ? ( window.$environment.packageConfig.apiType === 0 ? 'DAPI' : 'Nucleo' ) : 'MRAID' }`, lablColor, descColor );
      
              console.log( `%c AndroidStoreLink: %c${ UnityEngine.Application.androidStoreLink }`, lablColor, descColor );
              console.log( `%c IosStoreLink: %c${ UnityEngine.Application.iosStoreLink }`, lablColor, descColor );
              console.log( `%c ColorSpace: %c${ System.Enum.getName( UnityEngine.ColorSpace, pc.ProjectSettings.instance.desiredColorSpace ) }`, lablColor, descColor );
              if ( window.lunaStartup ) {
                  console.log( `%c AverageStartup: %c${ window.lunaStartup.measuredTime.avgStartupTime }ms`, lablColor, descColor );
              } else {
                  console.log( '%c AverageStartup: %cWorks only with /?startup key', lablColor, descColor );
              }
      
              console.log( `%c Scene count: %c${ UnityEngine.SceneManagement.SceneManager.sceneCount }`, lablColor, descColor );
              /**
               * @type {string[]}
               */
              const scenes = [];
              UnityEngine.SceneManagement.SceneManager.scenes.forEach( ( scene ) => {
                  scenes.push( scene.name );
              } );
              console.log( `%c Scenes: %c${ scenes.join( '\n ' ) }`, lablColor, descColor );
      
              console.log( `%c BaseEncoding: %c${ UnityEngine.Application.base64enabled === 'True' ? 'Base64' : 'Base122' }`, lablColor, descColor );
              console.log( `%c MinifyEnabled: %c${ UnityEngine.Application.minifyEnabled }`, lablColor, descColor );
              console.log( `%c ForceUncompressed: %c${ UnityEngine.Application.isForceUncompressed }`, lablColor, descColor );
              console.log( `%c AntiAliasingEnabled: %c${ UnityEngine.Application.isAntiAliasingEnabled }`, lablColor, descColor );
              console.log( `%c LunaCompilerV2: %c${ UnityEngine.Application.isLunaCompilerV2Used }`, lablColor, descColor );
              console.log( '%c ---RuntimeAnalysis---', lablColor );
              console.log( `%c CodeStrippingEnabled: %c${ UnityEngine.Application.isRuntimeAnalysisEnabledForCode }`, lablColor, descColor );
              console.log( `%c ExcludedClassesCount: %c${ UnityEngine.Application.runtimeAnalysisExcludedClassesCount }`, lablColor, descColor );
              console.log( `%c ExcludedMethodsCount: %c${ UnityEngine.Application.runtimeAnalysisExcludedMethodsCount }`, lablColor, descColor );
              console.log( `%c ExcludedModules: %c${ UnityEngine.Application.runtimeAnalysisExcludedModules }`, lablColor, descColor );
              console.log( `%c ShaderStrippingEnabled: %c${ UnityEngine.Application.isRuntimeAnalysisEnabledForShaders }`, lablColor, descColor );
              const shadersReport = pc.UnityShader.generateReport();
              console.log( `%c ShadersCount: %c${ shadersReport.unityShadersCount }`, lablColor, descColor );
              console.log( `%c VariantsCount: %c${ shadersReport.totalVariantsCount }`, lablColor, descColor );
              console.log( `%c ShaderProgramsCount: %cVertex: ${ shadersReport.vertexShadersCount } Fragment: ${ shadersReport.fragmentShadersCount }`, lablColor, descColor );
              console.log( '%c ---TechnicalPerformance---', lablColor );
              const frameSample = app.counters.previous;
              const totalFrameTime = frameSample.times.frame;
              console.log( `%c RealtimeShadowsEnabled: %c${ UnityEngine.Application.isRealtimeShadowsEnabled }`, lablColor, descColor );
              console.log( `%c DynamicBatching: %c${ pc.ProjectSettings.instance.enableDynamicBatching }`, lablColor, descColor );
      
              const GraphicsConstraints = {
                  WebGLContext: 1,
                  WebGLShaders: 2,
                  WebGL2Context: 4,
                  WebGL2Shaders: 8,
              };
      
              let constraints = [
                  ( app.graphicsDevice.graphicsConstraint & GraphicsConstraints.WebGLContext ) ? 'WebGLContext' : '',
                  ( app.graphicsDevice.graphicsConstraint & GraphicsConstraints.WebGLShaders ) ? 'WebGLShaders' : '',
                  ( app.graphicsDevice.graphicsConstraint & GraphicsConstraints.WebGL2Context ) ? 'WebGL2Context' : '',
                  ( app.graphicsDevice.graphicsConstraint & GraphicsConstraints.WebGL2Shaders ) ? 'WebGL2Shaders' : '',
              ];
              constraints = constraints.filter( Boolean );
      
              console.log( `%c GraphicsConstraint: %c${ constraints.join( ' + ' ) }`, lablColor, descColor );
              console.log( `%c BakeReferenceAmbientProbe: %c${ UnityEngine.Application.isReferenceAmbientProbeBaked }`, lablColor, descColor );
              console.log( `%c DrawCalls: %c${ frameSample.drawCalls }`, lablColor, descColor );
              console.log( `%c FrameTime: %c${ totalFrameTime.toFixed( 2 ) }ms`, lablColor, descColor );
              console.log( `%c RenderTime: %c${ frameSample.times.render.toFixed( 2 ) }ms ${ ( frameSample.times.render / totalFrameTime * 100 ).toFixed( 2 ) }% of frame time`, lablColor, descColor );
              console.log( `%c ScriptsTime: %c${ frameSample.times.scripts.toFixed( 2 ) }ms ${ ( frameSample.times.scripts / totalFrameTime * 100 ).toFixed( 2 ) }% of frame time`, lablColor, descColor );
              console.log( `%c AnimationsTime: %c${ frameSample.times.animations.toFixed( 2 ) }ms ${ ( frameSample.times.animations / totalFrameTime * 100 ).toFixed( 2 ) }% of frame time`, lablColor, descColor );
              console.log( `%c AnimatorsTime: %c${ frameSample.times.animators.toFixed( 2 ) }ms ${ ( frameSample.times.animators / totalFrameTime * 100 ).toFixed( 2 ) }% of frame time`, lablColor, descColor );
              console.log( `%c Physics2DTime: %c${ frameSample.times.physics2d.toFixed( 2 ) }ms ${ ( frameSample.times.physics2d / totalFrameTime * 100 ).toFixed( 2 ) }% of frame time`, lablColor, descColor );
              console.log( `%c PhysicsTime: %c${ frameSample.times.physics.toFixed( 2 ) }ms ${ ( frameSample.times.physics / totalFrameTime * 100 ).toFixed( 2 ) }% of frame time`, lablColor, descColor );
              console.log( '%c ---MemoryUsage---', lablColor );
              try {
                  console.log( `%c HeapLimit: %c${ ( performance.memory.jsHeapSizeLimit / 1000000 ).toFixed( 2 ) } MB`, lablColor, descColor );
                  console.log( `%c TotalHeapSize: %c${ ( performance.memory.totalJSHeapSize / 1000000 ).toFixed( 2 ) } MB`, lablColor, descColor );
                  console.log( `%c UsedHeapSize: %c${ ( performance.memory.usedJSHeapSize / 1000000 ).toFixed( 2 ) } MB`, lablColor, descColor );
              } catch ( error ) {
                  console.log( 'Memory measurements are supported for Chrome (v7+, v18+ android), Edge (v79+), Opera (v15+, v14+ android), Samsung Internet (v1.0+), WebView Android (v37+)' );
              }
              console.log( '%c ---DebugInfo---', lablColor );
              console.log( `%c WebglVersion used: %c${ app.graphicsDevice.gl.getParameter( app.graphicsDevice.gl.VERSION ) }`, lablColor, descColor );
              console.log( `%c Webgl supported: %c${ app.counters.webglVersion }`, lablColor, descColor );
              const extensions = app.counters.webglExtensions.join( '\n ' );
              console.log( `%c WebglExtensions:\n %c${ extensions }`, lablColor, descColor );
              console.log( `%c PackagesInfo:\n%c${ UnityEngine.Application.packagesInfo }`, lablColor, descColor );
              console.log( `%c ExternalJSLibraries:\n %c${ UnityEngine.Application.externalJsLibraries }`, lablColor, descColor );
          };
      
          Luna.ShaderReport = () => pc.UnityShader.generateReport();
          Luna.StartupReport = () => console.log( app._startup_report );
      } );
      
    </script>
    <script data-startup-only>// USAGE:
// http://playable.url/?startup - basic usage, logs startup metrics, compute avg startup time for consecutive page reloads
// http://playable.url/?startup&clear - the same as just ?startup but clears all data from previous runs
// http://playable.url/?startup&runs=30 - reloads page 30 times and then logs startup metrics
// http://playable.url/?startup&runs=30&outliers=4 - reloads page 30 times and then logs startup metrics.
//     4 fastest and 4 slowest runs will be discarded, so that avg startup time will be based on 30 - 4 * 2 = 22 measurements.

( () => {
    if ( document.location.search.toLowerCase().indexOf( 'startup' ) === -1 ) {
        return;
    }

    // We hide usage of localStorage because some networks scans code with regex in order to detect its usage,
    // even if it's hidden under a url flag and never used in actual ad network
    const ls = window[ atob( 'bG9jYWxTdG9yYWdl' ) ];

    window.lunaStartup = {
        // Whole startup journey ( window.lunaStartup.logStartupEvent usages ):
        timestamps: {
            'luna:startup:htmlInitializationTimestamp': 0, // html loading started
            'DOMContentLoaded': 0, // html loading finished ( network related )
            'decompressionStarted': 0, // when we start decompressing the first asset
            'decompressionFinished': 0, // when we finish decompressing the last asset
            'luna:build': 0,
            'luna:start': 0, // Application.InitializeAsync() -> Bundles.LoadProjectSettingsAsync
            'luna:starting': 0, // bundle._downloadBundleDataAsync(), bundle._downloadBlobDataAsync()
            'luna:startup:bundlesLoad': 0, // Bundles loading started
            'luna:startup:loadSimpleAssetsAsync': 0, // ProjectSettings, texture, shader, mesh, video, sound, animationClip, blendTree, textAsset, urpAsset, audioMixer, physicsMaterial3d/2d, audioMixerSnapshot
            'luna:startup:shaderReady': 0, // Shader Compilation
            'luna:startup:loadComplexAssetsAsync': 0, // Cubemap, material, sprite, font, animatorController, animatorOverrideController
            'luna:startup:loadPrefabsAsync': 0, // Prefabs deserializations
            'luna:startup:loadScenesAsync': 0, // Scene assets deserialization. Final step of bundles loading
            'luna:started': 0, // Engine and scene are fully loaded and started (Load scene, invokeCallbacks (awake everything), call tick(update + renderFrame)
            'frame': 0, // First frame rendered on the screen
        },
        measuredTime: {
            'loadTime': 0, // Total Startup-time of playable
            'avgStartupTime': 0, // Average Startup-time of playable
        },

        logStartupEvent: function( event ) {
            this.timestamps[ event ] = performance.now();
        },

        notifyLoadingComplete: function() {
            const totalTime = this.toSeconds( this.timestamps.frame );
            const avgStartupTimeInfo = this.recordAverageStartupInfo( totalTime );
            if ( avgStartupTimeInfo !== null ) { // null means that page will be reloaded, alert will block that
                window.lunaStartup.measuredTime.avgStartupTime = avgStartupTimeInfo.avgStartupTime;
                const report = this.userFriendlyReport( totalTime.toFixed( 3 ), avgStartupTimeInfo.startupCount, avgStartupTimeInfo.avgStartupTime );
                pc.Application._currentApplication._startup_report = report;
                if ( document.location.search.toLowerCase().indexOf( 'startup' ) !== -1 ) {
                    // eslint-disable-next-line no-alert
                    window.alert( report );
                }
                return report;
            }

            return '';
        },

        recordAverageStartupInfo: function( totalTime ) {
            const pageParams = new URLSearchParams( location.search );
            const savedBuildID = ls.getItem( 'buildID' );
            const startupInfoJson = ls.getItem( 'startupMeasurements' ) || '{ "timings": [] }';
            let startupInfo = JSON.parse( startupInfoJson );
            const currentBuildID = Deserializers.buildID;
            const shouldClearSavedData = pageParams.has( 'clear' );
            if ( shouldClearSavedData || currentBuildID !== savedBuildID ) {
                startupInfo = { timings: [] };
                ls.setItem( 'buildID', currentBuildID );
            }
            pageParams.delete( 'clear' );

            startupInfo.timings.push( totalTime );
            ls.setItem( 'startupMeasurements', JSON.stringify( startupInfo ) );

            let shouldReloadPage = false;
            if ( pageParams.has( 'runs' ) ) {
                const runsRemaining = Number( pageParams.get( 'runs' ) );
                if ( runsRemaining <= 1 ) {
                    pageParams.delete( 'runs' );
                } else {
                    pageParams.set( 'runs', runsRemaining - 1 );
                    shouldReloadPage = true;
                }
            }
            history.replaceState( null, document.title, '?' + pageParams.toString() );
            if ( shouldReloadPage ) {
                location.reload();
                return null;
            }

            if ( pageParams.has( 'outliers' ) ) {
                let outliersToRemove = Number( pageParams.get( 'outliers' ) );
                startupInfo.timings.sort();
                while ( outliersToRemove > 0 ) {
                    startupInfo.timings.pop();
                    startupInfo.timings.shift();
                    outliersToRemove--;
                }
            }
            const startupTimesSum = startupInfo.timings.reduce( ( acc, t ) => acc + t, 0 );
            const startupCount = startupInfo.timings.length;
            const avgStartupTime = ( startupTimesSum / startupCount ).toFixed( 3 );
            return { startupCount: startupCount, avgStartupTime: avgStartupTime };
        },

        toSeconds( value ) {
            return ( value / 1000.0 );
        },

        toFormattedSeconds( value ) {
            return this.toSeconds( value ).toFixed( 3 );
        },

        toPercentsString( value, totalValue ) {
            return `${( value / totalValue * 100 ).toFixed( 1 )}%`;
        },

        userFriendlyReport: function( totalTime, startupCount, avgStartupTime ) {
            const targetPlatform = window.$environment.targetPlatform;
            let result = `Total (${targetPlatform}): ${totalTime}s - Average (${startupCount} startups): ${avgStartupTime}s\n`;

            // Compression might not be applied
            const decompressTime = this.toFormattedSeconds( this.timestamps.decompressionFinished - this.timestamps.decompressionStarted );

            let runningTotal = 0;
            const loadingTime = this.toFormattedSeconds( this.timestamps.DOMContentLoaded );
            const loadingTimePercents = this.toPercentsString( loadingTime, totalTime );
            result += `${loadingTime}s (${loadingTimePercents}) - Loading from network (Optimise with Size Breakdown, Base64/Base122):\n`;
            result += `  - Decompressions (async): ${decompressTime}s\n`;
            runningTotal += this.timestamps.DOMContentLoaded;

            const loadedAssemblies = Object.keys( Bridge.startup );
            const bridgeInitialisationTime = loadedAssemblies.reduce( ( accumulator, currentValue ) => accumulator + Bridge.startup[ currentValue ], 0 );
            result += `  - C# Code init: ${this.toFormattedSeconds( bridgeInitialisationTime )}s (Optimise with Runtime Analysis)\n`;

            // start -> starting -> bundles:load
            const bundlesParsingTime = this.toFormattedSeconds( this.timestamps[ 'luna:startup:bundlesLoad' ] - this.timestamps[ 'luna:start' ] );
            const bundlesParsingTimePercents = this.toPercentsString( bundlesParsingTime, totalTime );
            result += `${bundlesParsingTime}s (${bundlesParsingTimePercents}) - Assets Deserialization\n`;
            runningTotal += this.timestamps[ 'luna:startup:bundlesLoad' ] - this.timestamps[ 'luna:start' ];

            const simpleAssetsTime = this.toFormattedSeconds( this.timestamps[ 'luna:startup:loadSimpleAssetsAsync' ] - this.timestamps[ 'luna:startup:bundlesLoad' ] );
            const simpleAssetsTimePercents = this.toPercentsString( simpleAssetsTime, totalTime );
            result += `${simpleAssetsTime}s (${simpleAssetsTimePercents}) - Load: Textures, shaders, meshes, sounds, animations (Optimise with Size Breakdown)\n`;
            runningTotal += this.timestamps[ 'luna:startup:loadSimpleAssetsAsync' ] - this.timestamps[ 'luna:startup:bundlesLoad' ];

            const complexAssetsTime = this.toFormattedSeconds( this.timestamps[ 'luna:startup:loadComplexAssetsAsync' ] - this.timestamps[ 'luna:startup:loadSimpleAssetsAsync' ] );
            const complexAssetsTimePercents = this.toPercentsString( complexAssetsTime, totalTime );
            result += `${complexAssetsTime}s (${complexAssetsTimePercents}) - Load: Cubemaps, materials, sprites, fonts, animators\n`;
            runningTotal += this.timestamps[ 'luna:startup:loadComplexAssetsAsync' ] - this.timestamps[ 'luna:startup:loadSimpleAssetsAsync' ];

            const prefabsTime = this.toFormattedSeconds( this.timestamps[ 'luna:startup:loadPrefabsAsync' ] - this.timestamps[ 'luna:startup:loadComplexAssetsAsync' ] );
            const prefabsTimePercents = this.toPercentsString( prefabsTime, totalTime );
            result += `${prefabsTime}s (${prefabsTimePercents}) - Load: Prefabs\n`;
            runningTotal += this.timestamps[ 'luna:startup:loadPrefabsAsync' ] - this.timestamps[ 'luna:startup:loadComplexAssetsAsync' ];

            const sceneAssetsTime = this.toFormattedSeconds( this.timestamps[ 'luna:startup:loadScenesAsync' ] - this.timestamps[ 'luna:startup:loadPrefabsAsync' ] );
            const sceneAssetsTimePercents = this.toPercentsString( sceneAssetsTime, totalTime );
            result += `${sceneAssetsTime}s (${sceneAssetsTimePercents}) - Load: SceneData\n`;
            runningTotal += this.timestamps[ 'luna:startup:loadScenesAsync' ] - this.timestamps[ 'luna:startup:loadPrefabsAsync' ];

            const shaderReadyTime = this.toFormattedSeconds( this.timestamps[ 'luna:startup:shaderReady' ] - this.timestamps[ 'luna:startup:loadScenesAsync' ] );
            const shaderReadyTimePercents = this.toPercentsString( shaderReadyTime, totalTime );
            const shaderReport = pc.UnityShader.generateReport();
            result += `${shaderReadyTime}s (${shaderReadyTimePercents}) - Shaders compilation (Shaders: ${shaderReport.unityShadersCount}, Variants: ${shaderReport.totalVariantsCount}) (Optimise with Runtime Analysis)\n`;
            runningTotal += this.timestamps[ 'luna:startup:shaderReady' ] - this.timestamps[ 'luna:startup:loadScenesAsync' ];

            const initialSceneTime = this.toFormattedSeconds( this.timestamps[ 'luna:started' ] - this.timestamps[ 'luna:startup:shaderReady' ] );
            const initialSceneTimePercents = this.toPercentsString( initialSceneTime, totalTime );
            result += `${initialSceneTime}s (${initialSceneTimePercents}) - Scene Loading and Awake (Optimise initialisation code)\n`;
            runningTotal += this.timestamps[ 'luna:started' ] - this.timestamps[ 'luna:startup:shaderReady' ];

            const firstFrameTime = this.toFormattedSeconds( this.timestamps.frame - this.timestamps[ 'luna:started' ] );
            const firstFrameTimePercents = this.toPercentsString( firstFrameTime, totalTime );
            result += `${firstFrameTime}s (${firstFrameTimePercents}) - First frame time (Simplify shaders)\n`;
            runningTotal += this.timestamps.frame - this.timestamps[ 'luna:started' ];

            result += `${this.toFormattedSeconds( runningTotal )}s (${this.toPercentsString( runningTotal / 1000, totalTime )}) - Running Total\n`;
            if ( targetPlatform === 'develop' ) {
                result += 'For "develop" platform, build optimisations are not applied. Check final result on actual platform build on devices.\n';
            }

            return result;
        },

        /**
         * Prints delta for all logged events
         */
        debugReport: function() {
            const keys = Object.keys( this.timestamps );
            const values = Object.values( this.timestamps );
            const totalTime = this.toFormattedSeconds( values[ values.length - 1 ] - values[ 0 ] );
            let result = `Total: ${totalTime} seconds\n\n`;
            for ( let i = 1; i < values.length; i++ ) {
                const dT = this.toFormattedSeconds( values[ i ] - values[ i - 1 ] );
                result += `${dT} sec : ${keys[ i ]}\n`;
            }
            return result;
        },
        /**
         * returns true after rendering the first frame
         * @returns {boolean}
         */
        isLoadingFinished: function() {
            return ( this.timestamps[ 'luna:started' ] > 0 && this.timestamps.frame > 0 );
        },
    };

    // Log initial time of HTML loading
    window.addEventListener( 'DOMContentLoaded', () => {
        window.lunaStartup.logStartupEvent( 'DOMContentLoaded' );
    } );

    window.addEventListener( 'luna:build', () => {
        window.lunaStartup.logStartupEvent( 'luna:build' );
    } );

    window.addEventListener( 'luna:start', () => {
        window.lunaStartup.logStartupEvent( 'luna:start' );
    } );

    window.addEventListener( 'luna:starting', () => {
        window.lunaStartup.logStartupEvent( 'luna:starting' );
    } );

    window.addEventListener( 'luna:startup:bundlesLoad', () => {
        window.lunaStartup.logStartupEvent( 'luna:startup:bundlesLoad' );
    } );

    window.addEventListener( 'luna:startup:loadSimpleAssetsAsync', () => {
        window.lunaStartup.logStartupEvent( 'luna:startup:loadSimpleAssetsAsync' );
    } );

    window.addEventListener( 'luna:startup:shaderReady', () => {
        window.lunaStartup.logStartupEvent( 'luna:startup:shaderReady' );
    } );

    window.addEventListener( 'luna:startup:loadComplexAssetsAsync', () => {
        window.lunaStartup.logStartupEvent( 'luna:startup:loadComplexAssetsAsync' );
    } );

    window.addEventListener( 'luna:startup:loadPrefabsAsync', () => {
        window.lunaStartup.logStartupEvent( 'luna:startup:loadPrefabsAsync' );
    } );

    window.addEventListener( 'luna:startup:loadScenesAsync', () => {
        window.lunaStartup.logStartupEvent( 'luna:startup:loadScenesAsync' );
    } );

    window.addEventListener( 'luna:started', () => {
        window.lunaStartup.logStartupEvent( 'luna:started' );
        window.lunaStartup.measuredTime.loadTime = window.lunaStartup.timestamps[ 'luna:started' ] - window.lunaStartup.timestamps[ 'luna:startup:htmlInitializationTimestamp' ];

        const app = pc.Application.getApplication();
        // for backward compatibility, in our Playable tests we have older version of Application events,
        // where we patched application itself with events compatibility
        const events = app.events || app;
        events.once( 'postrender', () => {
            window.lunaStartup.logStartupEvent( 'frame' );

            // frame won't be rendered until requestAnimationFrame callback is finished,
            // so let's wait for next frame to show alert
            events.once( 'prerender', () => {
                window.lunaStartup.notifyLoadingComplete();
            }, this );
        }, this );
    } );
} )();

    </script>
    <script data-startup-only>
      if ( document.location.search.toLowerCase().indexOf( 'spector' ) >= 0 ) {
          const spectorScript = document.createElement( 'script' );
          spectorScript.setAttribute( 'src', 'https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js' );
          document.head.appendChild( spectorScript );
      
          spectorScript.addEventListener( 'load', () => {
              window.spector = new SPECTOR.Spector();
              window.spector.spyCanvases();
              window.spector.displayUI();
          } );
      };
      
      window.addEventListener( 'luna:started', function () {
          // https://github.com/mrdoob/stats.js/
          if ( document.location.search.indexOf( 'fps' ) >= 0 ) {
              const script = document.createElement( 'script' );
              script.onload = function () {
                  const stats = new Stats();
                  document.body.appendChild( stats.dom );
                  window.app.app.events.on( 'postrender', function loop() {
                      stats.update();
                  }, this );
              };
      
              script.src = 'https://mrdoob.github.io/stats.js/build/stats.min.js';
              document.head.appendChild( script );
          }
      } );
      
      window.addEventListener( 'luna:start', function () {
          if ( document.location.search.indexOf( 'bundles' ) >= 0) {
              LunaUnity.Objects.Bundle.cleanup = () => {
                  console.log( 'Bundle.cleanup suppressed' )
                  window.addEventListener( 'luna:startup:bundlesLoad', () => {
                      LunaUnity.Objects.Bundle.cleanup = () => { console.log( 'Bundle.cleanup suppressed' ) };
                  } );
              }
          }
      } );
      
      window.addEventListener( 'luna:started', function () {
          if ( document.location.search.indexOf( 'bundles' ) >= 0) {
              const app = pc.Application.getApplication();
              const events = app.events || app;
              events.once( 'postrender', () => {
                  var fn = ( totals, curGameObject ) => {
                      for ( let i = 0; i < curGameObject.children.length; i++ ) {
                          var child = curGameObject.children[ i ];
                          totals.gameObjects += 1;
                          totals.components += child.components.length;
                          fn( totals, child );
                      }
                  };
                  var message = '';
                  var bundles = Object.values( LunaUnity.Objects.Bundle._bundles );
                  for ( var i = 0; i < bundles.length; i++ ) {
                      var bundle = bundles[ i ];
                      message += `Bundle ${ bundle.manifest.id }( ${ ( bundle.blob.byteLength / 1000000 ).toFixed( 3 ) } MB ):\n`;
      
                      var handlers = Object.values( bundle.json );
                      var handlerNames = Object.keys( bundle.json );
                      for ( var j = 0; j < handlers.length; j++ ) {
                          var handler = handlers[ j ];
                          var handlerName = handlerNames[ j ];
                          message += `  ${ handlerName }: ${ handler.length } `;
                          switch ( handlerName ) {
                              case 'scriptable-objects':
                                  break;
                              case 'textures':
                                  var totals = { size: 0 };
                                  for ( let i = 0; i < handler.length; i++ ) {
                                      totals.size += handler[ i ].data[ 1 ] * handler[ i ].data[ 2 ] * 4;
                                  }
                                  message += `( ByteSize: ${ ( totals.size / 1000000 ).toFixed( 3 ) } MB )`;
                                  break;
                              case 'meshes':
                                  message += ``;
                                  break;
                              case 'scenes':
                                  var totals = { gameObjects: 0, components: 0 };
                                  var roots = handler[0].objects;
                                  for ( let i = 0; i < roots.length; i++ ) {
                                      fn( totals, roots[ i ] );
                                  }
                                  message += `( GameObjects: ${ totals.gameObjects }, Components ${ totals.components } )`;
                                  break;
                              case 'prefabs':
                                  var totals = { gameObjects: 0, components: 0 };
                                  for ( let i = 0; i < handler.length; i++ ) {
                                      fn( totals, handler[ i ] );
                                  }
                                  message += `( GameObjects: ${ totals.gameObjects }, Components ${ totals.components } )`;
                                  break;
                              case 'animation-clips':
                                  var totals = { curves: 0, keys: 0 };
                                  const ANIMATION_CLIP_FIELDS = Deserializers.fields[ 'Luna.Unity.DTO.UnityEngine.Animation.Data.AnimationClip' ];
                                  const ANIMATION_CURVE_FIELDS = Deserializers.fields[ 'Luna.Unity.DTO.UnityEngine.Animation.Data.AnimationCurve' ];
                                  const ANIMATION_EVENT_FIELDS = Deserializers.fields[ 'Luna.Unity.DTO.UnityEngine.Animation.Data.AnimationEvent' ];
                                  for ( let i = 0; i < handler.length; i++ ) {
                                      var animationClip = handler[ i ];
                                      var data = animationClip.data;
                                      const curvesData = data[ ANIMATION_CLIP_FIELDS.curves ];
                                      totals.curves += curvesData.length;
                                      for ( let j = 0; j < curvesData.length; j++ ) {
                                          var curveData = curvesData[ j ];
                                          const keysBlobSize = curveData[ ANIMATION_CURVE_FIELDS.keys ];
                                          var byteSize = keysBlobSize[ 1 ];
                                          var keys = byteSize / ( data[ ANIMATION_CLIP_FIELDS.halfPrecision ] ? 2 : 4) / 7;
                                          totals.keys += keys;
                                      }
                                  }
                                  message += `( Curves: ${ totals.curves }, Keys ${ totals.keys } )`;
                                  break;
                          }
                          message += '\n'
                      }
                  }
                  console.log( message );
                  window.alert( message );
              }, this );
          }
      } );
    </script>
    <script>( function() {
    // Helper functions

    /**
     * MurMurHash3, 32 bit flavour.
     */
    // eslint-disable-next-line
    window.murmurhash3_32_gc = function(e,c) {var h,r,t,a,o,d,A,C;for(h=3&e.length,r=e.length-h,t=c,o=3432918353,d=461845907,C=0;C<r;)A=255&e.charCodeAt(C)|(255&e.charCodeAt(++C))<<8|(255&e.charCodeAt(++C))<<16|(255&e.charCodeAt(++C))<<24,++C,t=27492+(65535&(a=5*(65535&(t=(t^=A=(65535&(A=(A=(65535&A)*o+(((A>>>16)*o&65535)<<16)&4294967295)<<15|A>>>17))*d+(((A>>>16)*d&65535)<<16)&4294967295)<<13|t>>>19))+((5*(t>>>16)&65535)<<16)&4294967295))+((58964+(a>>>16)&65535)<<16);switch(A=0,h){case 3:A^=(255&e.charCodeAt(C+2))<<16;case 2:A^=(255&e.charCodeAt(C+1))<<8;case 1:t^=A=(65535&(A=(A=(65535&(A^=255&e.charCodeAt(C)))*o+(((A>>>16)*o&65535)<<16)&4294967295)<<15|A>>>17))*d+(((A>>>16)*d&65535)<<16)&4294967295}return t^=e.length,t=2246822507*(65535&(t^=t>>>16))+((2246822507*(t>>>16)&65535)<<16)&4294967295,t=3266489909*(65535&(t^=t>>>13))+((3266489909*(t>>>16)&65535)<<16)&4294967295,(t^=t>>>16)>>>0}

    /**
     * Returns random string of exactly 16 characters long.
     */
    function generateSessionId() {
        // prepare working set. this is going to be a string of 12
        // characters since we will be encoding it using Base64 to get exactly 16
        // characters
        let accumulator = '';

        // check for crypto presence
        if ( window.crypto && window.crypto.getRandomValues ) {
            // allocate the buffer of 12 bytes so that we end up with 16 Base64 characters
            const buffer = new Uint8Array( 12 );
            // get random bytes
            window.crypto.getRandomValues( buffer );
            // transfer bytes to accumulator
            for ( let i = 0; i < buffer.length; i++ ) {
                accumulator += String.fromCharCode( buffer[ i ] );
            }
        } else {
            // prepare entropy values
            const entropies = [
                ( navigator.userAgent || navigator.vendor || window.opera ) + Math.random(),
                ( navigator.language || '' ) + window.innerWidth + window.innerHeight + Math.random(),
            ];

            try {
                // try using JSON representation of window.performance
                // this is by far the best entropy source available to us since it contains high-precision
                // clock initialization values.
                //
                // this, however, is a bit tricky: we cannot count on it being serializable since
                // SDKs/webviews can extend this object and introduce, say, circular references,
                // breaking JSON serialization  that's why try ... catch
                entropies.push( JSON.stringify( window.performance ) + Math.random() );
            } catch ( ex ) {
                // ok, something went wrong - fall back to "normal" date value instead
                entropies.push( new Date().valueOf().toString() );
            }

            // hash each entropy and place hash values into byte array
            for ( let i = 0; i < 3; i++ ) {
                // compute murmur hash
                let hash = window.murmurhash3_32_gc( entropies[ i ] );

                // transfer bytes of the number over to accumulator
                for ( let j = 0; j < 4; j++ ) {
                    accumulator += String.fromCharCode( hash & 0xff );
                    hash >>= 8;
                }
            }
        }

        // convert to Base64 string
        return btoa( accumulator );
    }

    /**
     * Returns true if the browser seems to support WebAssembly.
     */
    function checkWasmSupport() {
        try {
            // first of, check the presense of classes
            if ( ( typeof WebAssembly === 'object' ) && ( typeof WebAssembly.instantiate === 'function' ) ) {
                // try assembling a new WASM module from a minimal bytecode
                const wasmModule = new WebAssembly.Module( new Uint8Array( [ 0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00 ] ) );
                // check that the module did assemble
                if ( wasmModule instanceof WebAssembly.Module ) {
                    // finally, check the instantiation bit
                    return ( new WebAssembly.Instance( wasmModule ) instanceof WebAssembly.Instance );
                }
            }
        } catch ( e ) {
            // eat up all exceptions
        }

        return false;
    }

    // Prepare and cache timer function
    const now = ( !window.performance || !window.performance.now || !window.performance.timing ) ? Date.now : function() {
        return window.performance.now();
    };

    /**
     * Represents Luna PI runtime interface designed for collection platform information
     * and data.
     *
     * @param    {String}    adNetwork      Ad network identifier.
     * @param    {String}    appId          Unique app identifier.
     * @param    {String}    signature      Signature to use.
     * @param    {String}    buildId        Unique build identifier.
     * @param    {String}    statsUrl       Base URL for stats endpoint.
     * @param    {String}    configUrl      Config URL for remote config endpoint.
     * @param    {String}    configTimeout  Config loading timeout.
     * @param    {String}    configDelay    Config loading delay.
     */
    const PlayableInsights = function( adNetwork, appId, buildId, signature, statsUrl, configUrl, configTimeout, configDelay, permutationWhitelist, errorEndpointUrl ) {
        this.env = {
            screenWidth: window.innerWidth,
            screenHeight: window.innerHeight,
            sessionId: generateSessionId(),
            signature: signature,
            locale: ( navigator.language || '' ).split( '-' )[ 0 ] || 'xx',
            version: 1,
            appId: appId,
            adNetwork: adNetwork,
            buildId: buildId,
            wasm: checkWasmSupport(),
            permutationId: 0,
            lastPing: 0,
            interactionClientX: 0,
            interactionClientY: 0,
            isRewarded: PlayableInsights.IS_REWARDED_UNKNOWN,
            webglVersion: window.WebGL2RenderingContext ? 2 : 1,
        };

        // holds the number of appearances of each event
        this.eventSequenceNumbers = {};
        this.totalEvents = 0;

        this.permutationWhitelist = permutationWhitelist;
        this.statsUrl = statsUrl;
        this.configUrl = configUrl;
        this.errorEndpointUrl = errorEndpointUrl;

        const currentNow = now();

        // configure separate timestamp "tracks" to be able to log independent time
        // offsets for various types of events
        this.timestamps = {
            default: {
                timestamp: currentNow,
                previousTimestamp: currentNow,
            },

            system: {
                timestamp: currentNow,
                previousTimestamp: currentNow,
            },
        };

        // set frame timestamp very far in the future
        this.frameTimestamp = 1e9;
        this.configTimeout = configTimeout;
        this.configDelay = configDelay;

        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        const isTouchDevice = navigator.maxTouchPoints && navigator.maxTouchPoints > 2;

        if ( /windows phone/i.test( userAgent ) ) {
            this.env.os = 'wp';
        } else if ( /android/i.test( userAgent ) ) {
            this.env.os = 'android';
        } else if ( /ipad|iphone|ipod/i.test( userAgent ) ) {
            this.env.os = 'ios';
        } else if ( /macintosh/i.test( userAgent ) && isTouchDevice && !window.MSStream ) {
            this.env.os = 'ios';
        } else {
            this.env.os = '';
        }

        this.env = Object.assign( this.env, window.PI_ENV_OVERRIDE || {} );

        this.subscribeToSystemEvents();
        this.fetchConfig();
        this.subscribeToInteraction();
    };

    // Set constructor
    PlayableInsights.prototype.constructor = PlayableInsights;

    // Prepare constants
    PlayableInsights.LOAD_EVENT_NAME = 'load';
    PlayableInsights.LOADED_EVENT_NAME = 'loaded';
    PlayableInsights.STARTING_EVENT_NAME = 'starting';
    PlayableInsights.STARTED_EVENT_NAME = 'started';
    PlayableInsights.INTERACTION_EVENT_NAME = 'interaction';
    PlayableInsights.CTA_EVENT_NAME = 'cta';
    PlayableInsights.SAMPLE_EVENT_NAME = 'sample';
    PlayableInsights.BOUNCE_EVENT_NAME = 'bounce';
    PlayableInsights.FRAME_EVENT_NAME = 'frame';
    PlayableInsights.CONFIG_EVENT_NAME = 'config';
    PlayableInsights.GAME_END_EVENT_NAME = 'game_end';
    PlayableInsights.INTERNAL_CLICK_EVENT_NAME = 'internal.click';
    PlayableInsights.CUSTOM_EVENT_NAME_PREFIX = 'custom.';
    PlayableInsights.SYSTEM_EVENT_NAME_PREFIX = 'system.';

    PlayableInsights.PERFORMANCE_SAMPLE_INTERVAL = 5 * 1000;
    PlayableInsights.BOUNCE_TIME_DIFFERENCE = 1000;

    PlayableInsights.FACEBOOK_AD_NETWORK_NAME = 'facebook';
    PlayableInsights.IRONSOURCE_AD_NETWORK_NAME = 'ironsource';
    PlayableInsights.VUNGLE_AD_NETWORK_NAME = 'vungle';
    PlayableInsights.MINTEGRAL_AD_NETWORK_NAME = 'mintegral';

    PlayableInsights.MAX_EVENTS = 256;
    PlayableInsights.MAX_SEQUENCE_NUMBER = 32;

    PlayableInsights.IS_REWARDED_TRUE = 1;
    PlayableInsights.IS_REWARDED_FALSE = 0;
    PlayableInsights.IS_REWARDED_UNKNOWN = 2;

    PlayableInsights.IRON_SOURCE_PRODUCT_TYPE_REWARDED_VIDEO = 'RewardedVideo';
    PlayableInsights.IRON_SOURCE_PRODUCT_TYPE_INTERSTITIAL = 'Interstitial';

    // Update prototype with methods
    Object.assign( PlayableInsights.prototype, {

        /**
         * Starts the procedure of fetching the remote config, if the URL was configured.
         */
        fetchConfig: function() {
            // memoize the timestamp
            this.configRequestedAt = now();

            // check if the config URL is present
            if ( !this.configUrl ) {
                // it's not - let's make our promise resolve with null instantly
                this.configFetchPromise = new Promise( ( resolve ) => {
                    resolve( null );
                } );

                return;
            }

            // construct config fetching promise and launch it like now
            this.configFetchPromise = fetch( this.configUrl ).then( ( response ) => response.json() ).catch( ( error ) => null );
        },

        /**
         * Returns a random number in [0..1) range used for picking a config
         * to show.
         */
        rollADice: function() {
            return window.PI_CONFIG_RANDOM || Math.random();
        },

        /**
         * Renders a debug dropdown overlaying the page with a list of baked permutations if the
         * playable URL contains mv_debug parameter.
         */
        selectPermutationFromUI: function() {
            if ( !location.search || location.search.indexOf( 'mv_debug=true' ) < 0 ) {
                return new Promise( ( resolve ) => {
                    resolve();
                } );
            }

            return new Promise( ( resolve ) => {
                const container = document.createElement( 'div' );
                container.style = 'background: white; overflow: scroll; position: absolute; z-index: 1000000; top: 50%; left: 50%; width: 90%; height: 20%; transform: translateX(-50%) translateY(-50%);';

                const onChange = function( id ) {
                    const data = window.pi.permutationWhitelist[ id ];

                    if ( !data ) {
                        window.pi.env.permutationId = 0;
                        window.playgroundOverrides = {};
                    } else {
                        window.pi.env.permutationId = id;
                        window.playgroundOverrides = data;
                    }

                    document.body.removeChild( container );

                    resolve();
                };

                for ( const id in window.pi.permutationWhitelist ) {
                    const option = document.createElement( 'a' );
                    const idValue = parseInt( id, 10 );

                    option.innerText = 'Permutation #' + id;
                    option.style = 'display: block; padding: 0.25em 0.5em; text-decoration: underline; position: static; color: black';
                    option.onclick = function() {
                        onChange( this );
                    }.bind( idValue );

                    container.appendChild( option );
                }

                document.body.appendChild( container );
            } );
        },

        /**
         * Filters the permutations against the whilelist and updates the thresholds so
         * that the relative weights remain valid.
         */
        filterPermutations: function( permutations ) {
            if ( !this.permutationWhitelist ) {
                return permutations;
            }

            let previousThreshold = 0.0;
            const weightMultiplier = 1e6;

            // iterate over all permutations and assign the weight
            for ( let i = 0; i < permutations.length; i++ ) {
                // get the permutation
                const permutation = permutations[ i ];

                // compute the real weight
                permutation.weight = weightMultiplier * ( permutation.threshold - previousThreshold );
                // update the preview
                previousThreshold = permutation.threshold;
            }

            // now, assemble a new array of permutations that ended up in the whitelist
            const filteredPermutations = [];
            // also, keep track of the total weight
            let totalWeight = 0.0;

            // iterate over all permutations again
            for ( let i = 0; i < permutations.length; i++ ) {
                // get the permutation
                const permutation = permutations[ i ];
                const bakedPermutationData = this.permutationWhitelist[ permutation.id ];

                // check that the permutation is present in the whitelist
                if ( bakedPermutationData ) {
                    // assemble the permutation
                    const bakedPermutation = { id: permutation.id, weight: permutation.weight, data: bakedPermutationData };
                    // append the permutation to the collection
                    filteredPermutations.push( bakedPermutation );
                    // accumulate the weight
                    totalWeight += bakedPermutation.weight;
                }
            }

            // now, recompute the thresholds
            let threshold = 0.0;

            // iterate over all permutations again
            for ( let i = 0; i < filteredPermutations.length; i++ ) {
                // get the permutation
                const permutation = filteredPermutations[ i ];

                threshold += permutation.weight / totalWeight;
                permutation.threshold = threshold;
            }

            return filteredPermutations;
        },

        /**
         * Attempts to find a specific permutation set matching current segment's value. If the current segment
         * is not provided in segments dictionary (e.g. an unknown platform is encountered), an empty array is
         * returned to avoid skewing the statistics.
         */
        collectPermutationsForSegment: function( permutations, segment, segments ) {
            // assemble a mapping from segment name to current segment value
            const currentSegmentValues = {
                os: this.env.os,
                ad_network: this.env.adNetwork,
                ad_network_os: `${this.env.adNetwork}@${this.env.os}`,
                orientation: this.env.screenWidth > this.env.screenHeight ? 'landscape' : 'portrait',
                locale: this.env.locale,
                none: '',
            };

            // extract weights corresponding to our segment (e.g. unityads if we are on unityads and segment is ad_network)
            const currentSegmentValue = currentSegmentValues[ segment ];
            const weights = segments[ currentSegmentValue ];

            // if no weights are found, we are not able to run any test  just return an empty array.
            // we could still serve a random permutation, but this data won't be used by test optimizer anyway, so let's
            // not bother for now
            if ( !weights ) {
                return [];
            }

            // collect specific permutations and their weights as per the configuration
            const result = weights.map( ( [ id, weight ] ) => ( { id, weight, data: permutations[ id ] } ) );

            // convert weights into thresholds to help random pick one
            const totalWeight = result.reduce( ( total, permutation ) => total + permutation.weight, 0 );
            let threshold = 0.0;

            return result.map( ( permutation, index ) => {
                // advance the threshold
                threshold += permutation.weight / totalWeight;

                // make sure the last elemnt's threshold is set to 1 to avoid rounding trap
                if ( index === result.length - 1 ) {
                    threshold = 1.0;
                }

                return { ...permutation, threshold };
            } );
        },

        /**
         * Awaits fetchConfigPromise and attempts to update PG overrides
         * based on the data received.
         */
        selectPermutationFromConfig: function() {
            const timeBudget = Math.max( 0, Math.min( this.configDelay, this.configTimeout - now() ) );

            this.configTimeoutPromise = new Promise( ( resolve ) => {
                setTimeout( resolve, timeBudget );
            } );

            const promise = Promise.race( [
                this.configFetchPromise,
                this.configTimeoutPromise,
            ] );

            const number = this.rollADice();
            const configRequestedAt = this.configRequestedAt;

            return promise.then( ( json ) => {
                // check that we have a valid JSON (either v1 or v2)
                if ( !json || !( json.permutations || json.all_permutations ) ) {
                    return;
                }

                // unpack permutations into initial set
                let permutationSet = json.permutations;

                // check if v2 manifest is in play  if so, use segment value to gather particular set
                if ( json.segments ) {
                    permutationSet = window.pi.collectPermutationsForSegment( json.all_permutations, json.segment, json.segments );
                }

                // filter the permutations against the whilelist, if one is supplied
                const permutations = window.pi.filterPermutations( permutationSet );

                // find a permutation that suits us
                for ( let i = 0; i < permutations.length; i++ ) {
                    const permutation = permutations[ i ];

                    // check that threshold is equal or above the random number
                    if ( permutation.threshold >= number ) {
                        window.pi.env.permutationId = permutation.id;
                        window.playgroundOverrides = permutation.data;

                        break;
                    }
                }

                // log the event along with timedelta
                window.pi.logEvent( PlayableInsights.CONFIG_EVENT_NAME, false, { timedelta: now() - configRequestedAt } );
            } );
        },

        /**
         * Awaits config promise along with Bridge.ready event and executes the callback.
         */
        ready: function( callback ) {
            Promise.all( [
                new Promise( Bridge.ready ),
                this.selectPermutationFromConfig(),
                this.selectPermutationFromUI(),
            ] ).then( callback );
        },

        /**
         * Attaches internal handlers to application object.
         *
         * @param    {pc.Application}    app    Applicaiton object to listen.
         */
        attachTo: function( app ) {
            // [NOTE] we need to support playables built with old pc.events here
            this.app = app;

            this.app.events ?
                this.app.events.on( 'postrender', this.onPostRender, this ) :
                this.app.on( 'postrender', this.onPostRender, this );
        },

        /**
         * Subscribes logger to user interactions.
         */
        subscribeToInteraction: function() {
            document.addEventListener( 'DOMContentLoaded', () => {
                // also, watch for touch/click events to support interaction event
                this.onInteractionCallback = this.onInteraction.bind( this );
                document.body.addEventListener( 'click', this.onInteractionCallback );
                document.body.addEventListener( 'touchstart', this.onInteractionCallback );
            } );
        },

        /**
         * Logs interaction event, but only once.
         */
        onInteraction: function( event ) {
            if ( this.isEventLogged( PlayableInsights.FRAME_EVENT_NAME, 1 ) && !this.isEventLogged( PlayableInsights.INTERACTION_EVENT_NAME, 1 ) ) {
                this.captureInteractionEventData( event );
                this.logInteraction( event );
            }

            if ( !this.isEventLogged( PlayableInsights.INTERNAL_CLICK_EVENT_NAME, 5 ) ) {
                this.captureInteractionEventData( event );
                this.logEvent( PlayableInsights.INTERNAL_CLICK_EVENT_NAME, false, {} );
            }
        },

        /**
         * Extracts coordinates from the interaction events and stores them in the env so that upcoming
         * event logs can use these during reports.
         *
         * @param {Event}    event     Event instance to grab details from.
         */
        captureInteractionEventData: function( event ) {
            const touchSource = event.type === 'touchstart' ? event.touches[ 0 ] : event;

            this.env.interactionClientX = ( touchSource.clientX * 1.0 / window.innerWidth );
            this.env.interactionClientY = ( touchSource.clientY * 1.0 / window.innerHeight );
        },

        /**
         * Starts watching for the bounce-back event to measure time step in store.
         */
        startWatchingBounce: function() {
            this.onRequestAnimationFrameTimestamp = now();
            this.onRequestAnimationFrameCallback = this.onRequestAnimationFrame.bind( this );

            this.onRequestAnimationFrameCallback();
        },

        /**
         * The callback for requestAnimationFrame indicating the webview is foreground and can render
         * bits onto the screen.
         */
        onRequestAnimationFrame: function() {
            const delta = now() - this.onRequestAnimationFrameTimestamp;

            if ( delta > PlayableInsights.BOUNCE_TIME_DIFFERENCE ) {
                this.logBounce( delta );
            }

            this.onRequestAnimationFrameTimestamp = now();
            window.requestAnimationFrame( this.onRequestAnimationFrameCallback );
        },

        /**
         * Awaits the postrender event and reports 'frame' event if it hapenned to have non-zero
         * screen size and we actually believe it's doing some "real" rendering now rather then being
         * hidden by an overlay or a video.
         */
        onPostRender: function() {
            if ( window.innerWidth <= 1 || window.innerHeight <= 1 ) {
                return;
            }

            // unsubscribe from the rendering events, just in case
            if ( this.app ) {
                if ( this.app.events ) {
                    this.app.events.off( 'postrender', this.onPostRender, this );
                } else {
                    this.app.off( 'postrender', this.onPostRender, this );
                }
            }

            this.logFrame();
        },

        /**
         * Acts as a callback for requestAnimationFrame() routine reporting frame event as soon as it is invoked
         * and window size execeeds 0x0 :)
         */
        onFirstFrame: function() {
            if ( window.innerWidth <= 1 || window.innerHeight <= 1 ) {
                window.requestAnimationFrame( this.onFirstFrameCallback );
                return;
            }

            this.logFrame();
        },

        /**
         * Logs an arbitrary event to the server.
         *
         * @param {String} eventName - Name of the event to log.
         * @param {bool} resetTimestamp - Whether to reset the timestamp.
         * @param {Object} options - Optional data to overwrite in the event.
         */
        logEvent: function( eventName, resetTimestamp, options ) {
            // try injecting network-specific data items
            this.injectIronSourceAdData();
            this.injectVungleAdData();
            this.injectMintegralAdData();

            // increment the counter
            this.totalEvents++;

            return new Promise( ( resolve, reject ) => {
                try {
                    // try updating the dimensions
                    this.env.screenWidth = window.innerWidth;
                    this.env.screenHeight = window.innerHeight;

                    let json = Object.assign( {}, this.env );
                    const time = now();

                    // optionally populate app performance metrics
                    if ( this.app && this.app.counters ) {
                        json = Object.assign( json, this.app.counters.getSnapshot() );
                    }

                    // decide which timestamp track to use
                    let timestamps = this.timestamps.default;
                    if ( eventName.indexOf( PlayableInsights.SYSTEM_EVENT_NAME_PREFIX ) === 0 ) {
                        timestamps = this.timestamps.system;
                    }

                    // populate JSON with event data.
                    json.timestamp = time - timestamps.timestamp;
                    json.timedelta = time - timestamps.previousTimestamp;
                    json.eventName = eventName;

                    // update previou event's timestamp
                    if ( resetTimestamp ) {
                        timestamps.previousTimestamp = time;
                    }

                    // update frameTimestamp if it's a frame event
                    if ( eventName === PlayableInsights.FRAME_EVENT_NAME ) {
                        this.frameTimestamp = time;
                    }

                    // update timestampSinceFrame field, falling back to -1 if the frame timestamp is in the future
                    // meaning the frame event didn't occur yet
                    json.timestampSinceFrame = Math.max( -1, time - this.frameTimestamp );

                    // optionally override event fields with the options provided.
                    if ( options ) {
                        json = Object.assign( json, options );
                    }

                    // lazily initialize event's seq no and increment it
                    json.seqNo = this.incrementSequenceNumber( eventName );

                    // check that limits are ok
                    if ( !this.validateEventLimits( eventName ) ) {
                        return;
                    }

                    const endpointToUse = json.errorMessage ? this.errorEndpointUrl : this.statsUrl;

                    if ( endpointToUse ) {
                        // prepare body data
                        const body = JSON.stringify( json );
                        const requestStartedAt = now();

                        // debug log
                        if ( this.displayEvents() ) {
                            console.log( ': Logging event ' + body + ' to ' + endpointToUse );
                        }

                        // actually perform the postback
                        fetch( endpointToUse, {
                            method: 'POST',
                            mode: 'no-cors',
                            body: body,
                        } )
                            .then( () => {
                                // debug log
                                if ( this.displayEvents() ) {
                                    console.log( ': Event delivered!' );
                                }

                                window.pi.env.lastPing = ( now() - requestStartedAt ) | 0;
                                resolve();
                            }, ( error ) => {
                                // debug log
                                console.warn( ': Event failed at dilvery: ' + error );
                                reject( error );
                            } );
                    } else {
                        // debug log
                        if ( this.displayEvents() ) {
                            console.log( ': Not logging event ' + eventName + ' as no endpoint URL is provided!' );
                        }

                        resolve();
                    }
                } catch ( ex ) {
                    // debug log
                    console.warn( ': Exception during submitting the event: ' + ex );
                    reject( ex );
                }
            } );
        },

        /**
         * Check is logEvents should be showed.
         */
        displayEvents: function() {
            // eslint-disable-next-line no-undef
            return ( window.hasOwnProperty( 'DEBUG' ) && DEBUG ) || ( window.hasOwnProperty( 'TESTS' ) && TESTS );
        },

        /**
         * Logs 'load' event.
         */
        logLoad: function() {
            this.logEvent( PlayableInsights.LOAD_EVENT_NAME, true, null );
        },

        /**
         * Logs 'loaded' event.
         */
        logLoaded: function() {
            this.logEvent( PlayableInsights.LOADED_EVENT_NAME, true, null );
        },

        /**
         * Logs 'starting' event.
         */
        logStarting: function() {
            this.logEvent( PlayableInsights.STARTING_EVENT_NAME, true, null );
        },

        /**
         * Logs 'started' event.
         */
        logStarted: function() {
            this.logEvent( PlayableInsights.STARTED_EVENT_NAME, true, null );

            // check if this is a third-party playable
            if ( !window.UnityEngine ) {
                // it seems to be it - let's await for frame event as best as we can :)
                this.onFirstFrameCallback = this.onFirstFrame.bind( this );
                window.requestAnimationFrame( this.onFirstFrameCallback );
            }

            this.performanceSampleInterval = this.performanceSampleInterval || setInterval( this.logSample.bind( this ), PlayableInsights.PERFORMANCE_SAMPLE_INTERVAL );
        },

        /**
         * Logs 'interaction' event.
         */
        logInteraction: function( event ) {
            this.logEvent( PlayableInsights.INTERACTION_EVENT_NAME, true, null );
        },

        /**
         * Logs 'cta' event.
         */
        logCta: function() {
            this.logEvent( PlayableInsights.CTA_EVENT_NAME, true, null );
            this.startWatchingBounce();
        },

        /**
         * Logs 'sample' event.
         */
        logSample: function() {
            this.logEvent( PlayableInsights.SAMPLE_EVENT_NAME, false, null );
        },

        /**
         * Logs 'bounce' event.
         *
         * @param    {Number}    timedelta     Time delta to set.
         */
        logBounce: function( timedelta ) {
            this.logEvent( PlayableInsights.BOUNCE_EVENT_NAME, true, { timedelta: timedelta } );
        },

        /**
         * Logs 'bounce' event.
         *
         * @param    {Number}    timedelta     Time delta to set.
         */
        logFrame: function() {
            this.logEvent( PlayableInsights.FRAME_EVENT_NAME, true, null );
        },

        /**
         * Logs 'game_end' event.
         */
        logGameEnd: function() {
            this.logEvent( PlayableInsights.GAME_END_EVENT_NAME, false, null );
        },

        /**
         * Logs user-provided event checking that is does not intesect with
         * system events.
         *
         * @param    {String}    eventName     Event name to log.
         * @param    {Number}    intParameter  Custom integer parameter to use.
         */
        logCustomEvent: function( eventName, intParameter ) {
            // prefix custom event to avoid name clashes
            eventName = PlayableInsights.CUSTOM_EVENT_NAME_PREFIX + eventName;

            // issue the event call
            return this.logEvent( eventName, false, { intParameter: ( intParameter || 0 ) } );
        },

        /**
         * Returns true if the event has been logged already.
         *
         * @param    {String}    eventName     Event name to check.
         * @param    {Number}    threshold     The number of times to consider event "logged".
         */
        isEventLogged: function( eventName, threshold ) {
            if ( !this.eventSequenceNumbers.hasOwnProperty( eventName ) ) {
                return false;
            }

            return this.eventSequenceNumbers[ eventName ] >= threshold;
        },

        /**
         * Attempts to parse data provided by dapi.getAdData() or mraid.getMraidAdData()
         * to detect ad environment settings we are running in.
         */
        injectIronSourceAdData: function() {
            // check if impression id is already stored
            if ( this.env.impressionId ) {
                return;
            }

            // bail out if dapi is not available
            if ( this.env.adNetwork !== PlayableInsights.IRONSOURCE_AD_NETWORK_NAME ) {
                return;
            }

            try {
                // get ad data from dapi
                const adData = window.mraid ? mraid.getMraidAdData() : dapi.getAdData();

                // extract UII and from dapi's API
                this.env.impressionId = adData.UII;
                this.env.creativeId = adData.creativeId || '';
                this.env.campaignId = adData.campaignId || '';

                // detect rewarded status
                if ( adData.productType === PlayableInsights.IRON_SOURCE_PRODUCT_TYPE_REWARDED_VIDEO ) {
                    this.env.isRewarded = PlayableInsights.IS_REWARDED_TRUE;
                } else if ( adData.productType === PlayableInsights.IRON_SOURCE_PRODUCT_TYPE_INTERSTITIAL ) {
                    this.env.isRewarded = PlayableInsights.IS_REWARDED_FALSE;
                }
            } catch ( ex ) {
                // we are here if iS API is not avialable, so really nothing to do
            }
        },

        /**
         * Attempts to parse data provided by VungleHelper to detect ad environment settings we are running in.
         */
        injectVungleAdData: function() {
            // only try accessing Vungle data on Vungle (sic!)
            if ( this.env.adNetwork !== PlayableInsights.VUNGLE_AD_NETWORK_NAME ) {
                return;
            }

            // bail out if VungleHelper is not available
            if ( !window.VungleHelper ) {
                return;
            }

            try {
                // detect rewarded status
                if ( window.VungleHelper.rewardedAd === true ) {
                    this.env.isRewarded = PlayableInsights.IS_REWARDED_TRUE;
                } else if ( window.VungleHelper.rewardedAd === false ) {
                    this.env.isRewarded = PlayableInsights.IS_REWARDED_FALSE;
                }
            } catch ( ex ) {
                // we are here something went wrong.
            }
        },

        /**
         * Attempts to parse data provided by Mintegral to detect ad environment settings we are running in.
         */
        injectMintegralAdData: function() {
            // only try accessing Mintegral data on Mintegral (sic!)
            if ( this.env.adNetwork !== PlayableInsights.MINTEGRAL_AD_NETWORK_NAME ) {
                return;
            }

            // bail out if Mintegral data is not available
            if ( !window.MW_INIT ) {
                return;
            }

            try {
                // gather isRewardAds() value
                const isRewardAds = window.MW_INIT.isRewardAds();

                // detect rewarded status
                if ( isRewardAds === true ) {
                    this.env.isRewarded = PlayableInsights.IS_REWARDED_TRUE;
                } else if ( isRewardAds === false ) {
                    this.env.isRewarded = PlayableInsights.IS_REWARDED_FALSE;
                }
            } catch ( ex ) {
                // we are here something went wrong.
            }
        },

        /**
         * Initializes or increments sequence number for the given event name.
         *
         * @param    {String}    eventName     Event name to update sequence number for.
         */
        incrementSequenceNumber: function( eventName ) {
            this.eventSequenceNumbers[ eventName ] = ( this.eventSequenceNumbers[ eventName ] || 0 ) + 1;
            return this.eventSequenceNumbers[ eventName ];
        },

        /**
         * Returns true if current game session has not exceeded neither global event limit
         * nor specific one.
         *
         * @param    {String}    eventName     Event name to validate against limits.
         */
        validateEventLimits: function( eventName ) {
            // validate we are not exceeding global limit
            if ( this.totalEvents >= PlayableInsights.MAX_EVENTS ) {
                // debug log
                console.log( ': Skipping event ' + eventName + ' - already logged ' + PlayableInsights.MAX_EVENTS + ' events during the session' );
                // bail out
                return false;
            }

            // validate we are not exceeding per-event limit
            if ( this.eventSequenceNumbers[ eventName ] > PlayableInsights.MAX_SEQUENCE_NUMBER ) {
                // debug log
                console.log( ': Skipping event ' + eventName + ' - already logged ' + PlayableInsights.MAX_SEQUENCE_NUMBER + ' events of that name' );
                // bail out
                return false;
            }

            return true;
        },

        /**
         * If the random is in our favour (and not overriden - for test purposes), subsribe to system events to log
         * diagnostic messages to PI.
         */
        subscribeToSystemEvents: function() {
            // exit if system events are disabled explicitely
            if ( window.__playgroundInsightsEnableSystemEvents === false ) {
                return;
            }

            // exit if system events are not enabled forcefully and random is too high :)
            if ( window.__playgroundInsightsEnableSystemEvents !== true && Math.random() > 0.1 ) {
                return;
            }

            const systemEventsMap = [
                'DOMContentLoaded',
                'luna:build',
                'luna:start',
                'luna:startup:bundlesLoad',
                'luna:startup:loadSimpleAssetsAsync',
                'luna:startup:shaderReady',
                'luna:startup:loadComplexAssetsAsync',
                'luna:startup:loadPrefabsAsync',
                'luna:startup:loadScenesAsync',
                'luna:started',
            ];

            this.logEvent( 'system.load', false, {} );

            systemEventsMap.forEach( ( eventName ) => {
                window.addEventListener( eventName, () => {
                    this.logEvent( 'system.' + eventName.toLowerCase(), true, {} );
                } );
            } );
        },
    } );

    /**
     * "Patched" variant of logEvent function tailored to work for Facebook.
     *
     * @param    {String}    eventName          Name of the event to log.
     * @param    {Number}    resetTimestamp     Whether to reset the timestamp.
     * @param    {Object}    options            Optional data to overwrite in the event.
     */
    function logEventUsingFacebookAdSdk( eventName, resetTimestamp, options ) {
        if ( typeof FbPlayableAd === 'undefined' ) {
            console.warn( 'FbPlayableAd is not defined' );
            return;
        }

        // increment counters, global and per-event ones
        this.totalEvents++;
        this.incrementSequenceNumber( eventName );

        // validate the limits are not exceeded with this event
        if ( !this.validateEventLimits( eventName ) ) {
            return;
        }

        switch ( eventName ) {
            // we map 'loaded' event onto Facebook's game load event.
            case PlayableInsights.LOADED_EVENT_NAME: {
                FbPlayableAd.logGameLoad();
                console.log( ': Logged frame event as FbPlayableAd.logGameLoad' );
                break;
            }

            // we map 'starting', 'started' and 'frame' events onto Facebook's levelComplete event.
            case PlayableInsights.STARTING_EVENT_NAME:
            case PlayableInsights.STARTED_EVENT_NAME:
            case PlayableInsights.FRAME_EVENT_NAME:
            case PlayableInsights.GAME_END_EVENT_NAME: {
                FbPlayableAd.logLevelComplete( eventName );
                console.log( ': Logged ' + eventName + ' event as FbPlayableAd.logLevelComplete with ' + eventName );
                break;
            }

            // we map 'interaction' event onto Facebook's button click event
            case PlayableInsights.INTERACTION_EVENT_NAME: {
                FbPlayableAd.logButtonClick( 'interaction', 0, 0 );
                console.log( ': Logged interaction event as FbPlayableAd.logButtonClick' );
                break;
            }

            default: {
                console.log( ': Not logging ' + eventName + ' since it does not map to Facebook SDK' );
            }
        }
    }

    /**
     * "Patched" variant of logCustomEvent function tailored to work for Facebook.
     *
     * @param    {String}    eventName     Event name to log.
     * @param    {Number}    intParameter  Custom integer parameter to use.
     */
    function logCustomEventUsingFacebookAdSdk( eventName, intParameter ) {
        // increment counters, global and per-event ones
        this.totalEvents++;
        this.incrementSequenceNumber( eventName );

        // validate the limits are not exceeded with this event
        if ( !this.validateEventLimits( eventName ) ) {
            return;
        }

        // prefix custom event to avoid name clashes
        eventName = PlayableInsights.CUSTOM_EVENT_NAME_PREFIX + eventName;

        // piggy-back on logLevelComplete to store it (best we can do)
        // to do so, invent level name
        const levelName = [ 'custom', eventName, ( intParameter || 0 ) ].join( ':' );

        // log the event
        FbPlayableAd.logLevelComplete( levelName );
        console.log( ': Logged ' + eventName + ' event as FbPlayableAd.logLevelComplete with ' + levelName );
    }

    /**
     * Factory method that initializes Playable Insights class and re-assigns
     * the pi variable to the newly created instance.
     *
     * @param    {String}    adNetwork    Ad network identifier.
     * @param    {String}    appId        Unique app identifier.
     * @param    {String}    buildId      Unique build identifier.
     * @param    {String}    signature    Signature to use.
     * @param    {String}    statsUrl     Base URL for stats endpoint.
     * @param    {String}    configUrl    Base URL for config endpoint.
     */
    window.pi = function( adNetwork, appId, buildId, signature, statsUrl, configUrl, configTimeout, configDelay, permutationWhitelist, errorEndpointUrl ) {
        window.pi = new PlayableInsights( adNetwork, appId, buildId, signature, statsUrl, configUrl, configTimeout, configDelay, permutationWhitelist, errorEndpointUrl );

        // check if we are running in Facebook environment, and, if so, initialize
        // logging SDK and patch PI methods to report to Facebook
        if ( adNetwork === PlayableInsights.FACEBOOK_AD_NETWORK_NAME ) {
            if ( typeof FbPlayableAd !== 'undefined' ) {
                window.pi.logEvent = logEventUsingFacebookAdSdk;
                window.pi.logCustomEvent = logCustomEventUsingFacebookAdSdk;

                FbPlayableAd.initializeLogging( statsUrl + '/facebook', [ 'appId=', appId, '&buildId=', buildId, '&signature=', signature ].join( '' ) );
            } else {
                console.warn( 'FbPlayableAd is not defined' );
            }
        }

        window.pi.logLoad();
    };
} )();

    </script>
    <script>
      window.DEBUG = document.location.search.includes( 'debug' );
      window.TRACE = false;
      window.DEVELOP = false;
      window.TESTS = false;
      window.FORCE_STABLE_RANDOM_SEED = false;
      
    </script>
    <script>window.pi.apply( window, window.LUNA_PI_SETTINGS || [] );</script>
    <script>
      window.addEventListener( 'luna:ready', function() {
          window.dispatchEvent( new Event( 'luna:build' ) );
      } );
    </script>
    <script src="js/deserializers.js" defer type="text/javascript"></script>
    <script src="engine/luna/script-1.js" defer type="text/javascript"></script>
    <script src="engine/unity/bin/bridge.js" defer type="text/javascript"></script>
    <script src="engine/luna/physics3d-0.js" defer type="text/javascript"></script>
    <script src="engine/luna/physics2d-0.js" defer type="text/javascript"></script>
    <script src="engine/luna/mecanim-wasm-0.js" defer type="text/javascript"></script>
    <script src="engine/luna/script1.js" defer type="text/javascript"></script>
    <script src="engine/luna/urp-1.js" defer type="text/javascript"></script>
    <script src="engine/luna/physics3d-1.js" defer type="text/javascript"></script>
    <script src="engine/luna/particle-system-1.js" defer type="text/javascript"></script>
    <script src="engine/luna/physics2d-1.js" defer type="text/javascript"></script>
    <script src="engine/unity/bin/Bridge.Locales.js" defer type="text/javascript"></script>
    <script src="engine/unity/bin/UnityEngine.js" defer type="text/javascript"></script>
    <script src="engine/unity/bin/UnityEngine.UI.js" defer type="text/javascript"></script>
    <script src="engine/unity/bin/UnityEngine.UniversalRenderPipeline.js" defer type="text/javascript"></script>
    <script src="engine/unity/bin/TextMeshPro.js" defer type="text/javascript"></script>
    <script src="engine/unity/bin/DOTween.js" defer type="text/javascript"></script>
    <script src="engine/unity/bin/UnityScriptsCompiler.js" defer type="text/javascript"></script>
    <script src="engine/luna/script3.js" defer type="text/javascript"></script>
    <script>
      ( () => {
          function getChromeVersion() {
              const raw = navigator.userAgent.match( /Chrom(e|ium)\/([0-9]+)\./ );
              return raw ? parseInt( raw[ 2 ], 10 ) : false;
          }
      
          function getIosVersion() {
              // Ironsource userAgent example
              // Mozilla/5.0 (iPhone; CPU iPhone OS 15_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148
              const raw = navigator.userAgent.match( /(iPod|iPhone|iPad).*OS\s([0-9_]*)\s/ );
              return raw ? raw[ 2 ].replaceAll( '_', '.' ) : false;
          }
      
          function blobToBase64( blob ) {
              return new Promise( ( resolve ) => {
                  const reader = new FileReader();
                  reader.onloadend = function() {
                      resolve( reader.result );
                  }
                  reader.readAsDataURL( blob );
              } );
          }
      
          const _decode122Promises = [];
          for ( const element of document.querySelectorAll( '[data-src122]' ) ) {
              const dataset = element.dataset;
              const buffer = _base122ToArrayBuffer( dataset[ 'src122' ], true );
              const blob = new Blob( [ buffer ], { type: dataset[ 'mime' ] } );
              delete dataset[ 'src122' ];
              delete dataset[ 'mime' ];
      
              // Chrome under 52 version have a bug that do not allow to play media files that is set as a blob via create URL.
              // https://bugs.chromium.org/p/chromium/issues/detail?id=253465
              const chromeVersion = getChromeVersion();
      
              // Safari on iOS 15.4 version cannot play a video from data uri. Looks like iOS 17.4 has the same issue.
              // https://bugs.webkit.org/show_bug.cgi?id=232076
              const iosVersion = getIosVersion();
      
              if ( ( chromeVersion && chromeVersion < 52 ) ||
                  ( iosVersion && ( iosVersion.startsWith( '15.4' ) || iosVersion.startsWith( '17.4' ) ) )) {
                  blobToBase64( blob ).then( base64String => {
                      element.src = base64String;
                  } );
              } else {
                  element.src = URL.createObjectURL( blob );
              }
      
              if ( element instanceof HTMLImageElement && !element.complete ) {
                  // Videos does have a "is loaded" check in engine so we don't need to wait for them
                  _decode122Promises.push( new Promise( ( resolve ) => {
                      element.onload = resolve;
                  } ) );
              }
          }
          window._decode122Promise = Promise.all( _decode122Promises );
      } )();
    </script>
    <canvas id="application-canvas"></canvas>
    <script>
      window._bridgeReady = false;
      window._domReady = false;
      // Sometimes when using webworkers we decompress scripts before 'DOMContentLoaded' event causing listener
      // to think that it's dealing with builds with sync decompression. In this case two 'luna:ready' events will be emitted
      // and we want to prevent that
      window._readyEventEmitted = false;
      
      window.addEventListener( 'DOMContentLoaded', () => {
          if ( window._compressedAssets ) {
              Promise.all( window._compressedAssets ).then( () => window.dispatchEvent( new Event( 'bridge:ready' ) ) );
          }
      } );
      
      window.addEventListener( 'bridge:ready', function() {
          window._bridgeReady = true;
          if ( window._domReady && !window._readyEventEmitted ) {
              window._readyEventEmitted = true;
              window.dispatchEvent( new Event( 'luna:ready' ) );
          }
      } );
      
      window.addEventListener( 'DOMContentLoaded', function() {
          window._domReady = true;
          if ( 'Bridge' in window ) {
              // We're dealing with develop or test builds where bridge is included as a regular script and available
              // when DOMContentLoaded fired.
              // Otherwise bridge script is a part of compressed resources in html file and bridge:ready event will be fired
              // when it's available
              window._bridgeReady = true;
          }
          if ( window._bridgeReady && !window._readyEventEmitted ) {
              window._readyEventEmitted = true;
              window.dispatchEvent( new Event( 'luna:ready' ) );
          }
      } );
      
    </script>
    <script>
      function startGame() {
          return new Promise( function ( resolve, reject ) {
              pc.TextGenerator.fontRatio = 2.0;
      
              window.app = new LunaUnity.Application(
                  document.getElementById( "application-canvas" ),
                  window.$environment,
                  new LunaUnity.Application.StartupScene( "-1", "MyGame" )
              );
      
              const initializeTask = ( window.app.InitializeAsync && window.app.InitializeAsync() ) || System.Threading.Tasks.Task.fromResult( true );
              initializeTask.continueWith( function( status ) {
                  if ( status.exception ) {
                      console.error( 'Cannot start the game due to exception' );
                      reject( status.exception );
                      return;
                  }
      
                  // That event indicates that luna engine was successfully initialized and ready to process events
                  window.dispatchEvent( new Event( 'luna:initialized' ) );
                  window.dispatchEvent( new Event( 'luna:starting' ) );
      
                  window.app.StartWithJSCallback( function() {
                      var preloader = document.getElementById( "application-preloader" );
      
                      if ( preloader != null ) {
                          preloader.parentNode.removeChild( preloader );
                      }
      
                      resolve();
                  } );
              } );
          } );
      }
      
    </script>
    <script>
      ( function () {
          // the flag to store start game status to avoid double loads
          // in some ad networks
          var _startGame = false;
          // the flag indicating the game has completed startup sequence successfully
          var _startedGame = false;
          // the queue on unsafe events to re-trigger once the game starts
          var _unsafeEvents = [];
      
          // the routine that runs the startup sequence and makes sure startGame()
          // callback is invoked only once
          var startGameOnce = function () {
              // check that the game has not started yet
              if ( _startGame ) {
                  return;
              }
      
              // mark the game as started
              _startGame = true;
      
              var dispatchPostrenderEvent = function() {
                  var eventHandler = window.app.app.events || window.app.app;
                  eventHandler.off( 'postrender', dispatchPostrenderEvent );
      
                  window.dispatchEvent( new Event( 'luna:postrender' ) );
              };
      
              var dispatchStartedEvent = function() {
                  // We need the luna:initialized event here for the third-party Playables only, because unlike the Engine
                  // they do not have real initializing stage, but we want to trigger it anyway.
                  window.dispatchEvent( new Event( 'luna:initialized' ) );
                  window.dispatchEvent( new Event( 'luna:started' ) );
      
                  if ( window.app && window.app.app ) {
                      var eventHandler = window.app.app.events || window.app.app;
                      eventHandler.on( 'postrender', dispatchPostrenderEvent );
                  } else {
                      window.dispatchEvent( new Event( 'luna:postrender' ) );
                  }
              };
      
              var callback = function() {
                  const promisesToWait = [];
                  // We should wait for any base122-encoded assets to load. Engine code is written in a way that
                  // assumes that all inline image are ready when startGame is called, and we can't do anything
                  // about it cause we should be backward-compatible with old builds.
                  promisesToWait.push( window._decode122Promise || Promise.resolve() );
                  promisesToWait.push( ( window.pc && window.pc.waitForBox2D ) || Promise.resolve() );
                  promisesToWait.push( ( window.pc && window.pc.waitForMecanim ) || Promise.resolve() );
                  Promise.all( promisesToWait ).then( () => {
                      window._decode122Promise = null;
                      if ( window.pi ) {
                          // load 'starting' event
                          window.pi.logStarting();
                      }
      
                      // run the startup
                      var result = window.startGame();
      
                      // check if it returned a promise
                      if ( result && result.then ) {
                          // it is - await till it resolves
                          result.then( function () {
                              dispatchStartedEvent();
                          } );
                      } else {
                          // it is not - probably synchronous startup in effect?
                          dispatchStartedEvent();
                      }
                  } );
              };
      
              if ( window.pi ) {
                  // make sure PI is ready (i.e. config is fetched or timed out, initialization is complete etc)
                  window.pi.ready( callback );
              } else {
                  callback();
              }
          };
      
          window.addEventListener( 'luna:unsafe:mute', function () {
              if ( _startedGame ) {
                  window.dispatchEvent( new Event( 'luna:mute' ) );
              } else {
                  _unsafeEvents.push( 'luna:mute' );
              }
          } );
      
          window.addEventListener( 'luna:unsafe:unmute', function () {
              if ( _startedGame ) {
                  window.dispatchEvent( new Event( 'luna:unmute' ) );
              } else {
                  _unsafeEvents.push( 'luna:unmute' );
              }
          } );
      
          window.addEventListener( 'luna:unsafe:pause', function() {
              window.dispatchEvent( new Event( 'luna:unsafe:mute' ) );
      
              if ( _startedGame ) {
                  window.dispatchEvent( new Event( 'luna:pause' ) );
              } else {
                  _unsafeEvents.push( 'luna:pause' );
              }
          } );
      
          window.addEventListener( 'luna:unsafe:resume', function() {
              window.dispatchEvent( new Event( 'luna:unsafe:unmute' ) );
      
              if ( _startedGame ) {
                  window.dispatchEvent( new Event( 'luna:resume' ) );
              } else {
                  _unsafeEvents.push( 'luna:resume' );
              }
          } );
      
          window.addEventListener( 'luna:resume', function () {
              startGameOnce();
          } );
      
          window.addEventListener( 'luna:start', function () {
              startGameOnce();
          } );
      
          window.addEventListener( 'luna:initialized', function () {
              _startedGame = true;
      
              _unsafeEvents.forEach( function( eventName ) { window.dispatchEvent( new Event( eventName ) ) } );
              _unsafeEvents.length = 0;
          } );
      
          window.addEventListener( 'luna:started', function () {
              if ( !window.pi ) {
                  return;
              }
      
              if ( window.app && window.app.app ) {
                  window.pi.attachTo( window.app.app );
              }
      
              window.pi.logStarted();
          } );
      
          window.addEventListener( 'luna:build', function() {
              Bridge.ready( function() {
                  if ( window.pi ) {
                      Luna.Unity.LifeCycle.GameEnded = function() {
                          window.dispatchEvent( new Event( 'luna:ended' ) );
                          window.pi.logGameEnd();
                      }
      
                      Luna.Unity.Analytics.LogEvent$1 = window.pi.logCustomEvent.bind( window.pi );
                  }
              } );
          } );
      } )();
    </script>
    <script>
      ( function () {
          var _mute = false;
      
          window.audioVolumeToggle = function ( mute ) {
              if ( mute !== _mute ) {
                  _mute = mute;
      
                  if ( mute ) {
                      Luna.Unity.LifeCycle.OnMute();
                      window.app.app.muteAudio();
                  } else {
                      Luna.Unity.LifeCycle.OnUnmute();
                      window.app.app.unmuteAudio();
                  }
      
                  if ( window.app && window.app.AudioManager ) {
                      window.app.AudioManager.TriggerMasterVolumeChange( _mute ? 0 : 1 );
                  }
              }
          };
      
          window.addEventListener( "luna:unmute", function() {
              window.audioVolumeToggle( false );
          } );
      
          window.addEventListener( "luna:mute", function() {
              window.audioVolumeToggle( true );
          } );
      
          window.addEventListener( 'luna:pause', function () {
              if ( window.app && window.app.app ) {
                  Luna.Unity.LifeCycle.OnPause();
                  window.app.app.pause();
              }
          } );
      
          window.addEventListener( 'luna:resume', function () {
              if ( window.app && window.app.app ) {
                  Luna.Unity.LifeCycle.OnResume();
                  window.app.app.resume();
              }
          } );
      } )();
    </script>
    <script>
      window.DEVELOP = true;
      window.FORCE_STABLE_RANDOM_SEED = false;
      
      for ( const moduleName of $environment.runtimeAnalysisModules ) {
          window[ 'MODULE_' + moduleName ] = true;
      }
      
      function _isInsideIframe () {
          try {
              return window.self !== window.top;
          } catch (e) {
              return true;
          }
      }
      
      window.addEventListener( 'luna:ready', function() {
          if ( !_isInsideIframe() ) {
              // Autostart the game if iframe was opened directly
              window.dispatchEvent( new Event( 'luna:build' ) );
              window.dispatchEvent( new Event( 'luna:start' ) );
              window.dispatchEvent( new Event( 'playground:started' ) );
          }
      } );
      
    </script>
    <script>function replaceElementText( id, value ) {
    document.getElementById( id ).innerText = value[ 1 ];
}

function replaceElementColor( id, value ) {
    const r = ( ( value[ 1 ] * 255 ) | 0 ).toString( 16 );
    const g = ( ( value[ 2 ] * 255 ) | 0 ).toString( 16 );
    const b = ( ( value[ 3 ] * 255 ) | 0 ).toString( 16 );
    const a = ( ( value[ 4 ] * 255 ) | 0 ).toString( 16 );

    const color = '#' +
        ( r.length < 2 ? '0' : '' ) + r +
        ( g.length < 2 ? '0' : '' ) + g +
        ( b.length < 2 ? '0' : '' ) + b +
        ( a.length < 2 ? '0' : '' ) + a;

    document.getElementById( id ).style.background = color;
}

function replaceElementSrc( id, value ) {
    const element = document.getElementById( id );

    // store the original src value be able to restore it later
    if ( !element.dataset.src ) {
        element.dataset.src = element.src;
    }

    element.src = value[ 1 ] || element.dataset.src || element.src;
}

function updatePreloader( data ) {
    document.getElementById( 'application-preloader' ).style.display = 'block';

    for ( const [ key, value ] of Object.entries( data ) ) {
        switch ( value[ 0 ] ) {
            case 'image':
                replaceElementSrc( key, value );
                break;
            case 'string':
                replaceElementText( key, value );
                break;
            case 'color':
                replaceElementColor( key, value );
                break;
            default:
        }
    }
}

window.addEventListener( 'message', ( json ) => {
    try {
        if ( typeof json.data !== 'string' ) {
            // PG events always have a string payload, we can safely ignore the event if it's not the case.
            return;
        }
        const event = JSON.parse( json.data );

        switch ( event.name ) {
            case 'setPlaygroundOverrides':
                window.playgroundOverrides = JSON.parse( event.data );
                break;
            case 'setPlaygroundBundleOverrides':
                window.playgroundBundlesOverrides = JSON.parse( event.data );
                break;
            case 'setPlaygroundAssetOverrides':
                window.playgroundAssetOverrides = JSON.parse( event.data );

                window.dispatchEvent( new Event( 'luna:build' ) );
                window.dispatchEvent( new Event( 'luna:start' ) );
                window.dispatchEvent( new Event( 'playground:started' ) );

                break;
            case 'setPlaygroundPreloaderOverrides':
                updatePreloader( JSON.parse( event.data ) );

                break;
            default:
        }
    } catch ( ex ) {
        // noop
    }
} );

    </script>
    <script>window.addEventListener("luna:ready",(()=>{const e={GameStarted:"Game Started",GameUpdated:"Game Updated",GameEnded:"Game Ended",LevelChanged:"Level Changed",GamePaused:"Game Paused"};for(const t in e){const a=e[t];Luna.Unity.LifeCycle[t]=function(e){return function(t){try{const a=[];if(t)for(let e=0;e<t.length;e++)a[e]=t[e].$boxed?t[e].v:t[e];window.parent.postMessage({target:"editor",title:e,type:"secondary",params:JSON.stringify(a)},"*")}catch(e){console.warn(e)}}}(a)}Luna.Unity.Playable.InstallFullGame=function(){window.parent.postMessage({target:"editor",title:"CTA Button Clicked",type:"success"},"*"),window.parent.postMessage({target:"editor:pi",eventName:"cta",options:{}},"*")},Luna.Unity.LifeCycle.HapticTriggered=function(e){window.parent.postMessage({target:"editor",title:"Haptic Triggered",type:"light",params:{type:System.Enum.getName(Luna.Unity.HapticFeedbackType,e)}},"*")},window.pi.logEvent=function(e,t,a){window.parent.postMessage({target:"editor:pi",eventName:e,options:a},"*")}}));</script>
  </body><!-- htmlmin:ignore -->
</html><!-- htmlmin:ignore -->